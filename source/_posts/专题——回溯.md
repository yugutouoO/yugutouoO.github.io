---
title: 回溯
date: 2019-04-13 14:55:08
tags: 
- 算法题目分类
categories: 算法和数据结构
---
# 思路概述：
网上很多文章都说到了这种思想，[参考](http://www.voidcn.com/article/p-phdmgdjq-gz.html)
回溯法有“通用的解题法”之称。用它可以系统地搜索一个问题的所有解或任一解。回溯法是一个既带有系统性又带有跳跃性的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。算法搜索至解空间树的任一节点时，总是先判断该节点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的系统搜索，逐层向其祖先节点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根节点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可结束。这种以深度优先的方式系统地搜索问题的解算法称为回溯法，它适用于解一些组合数较大的问题。

参考复习回溯的思想很好理解，如果画图你肯定知道是怎么回事，**关键在于代码的实现**

使用回溯法的一般步骤：

1. 确定所给问题的解空间：首先应明确定义问题的解空间，解空间中至少包含问题的一个解。
2. 确定结点的扩展搜索规则
3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

回溯题目：
1. 子集
2. 子集 II （含重复）
3. 数字的全排列
4. 数字的全排列 II（含重复）
5. 字符串的全排列

# 子集
## 78. Subsets
原题：https://leetcode.com/problems/subsets/
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:
```
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```
分析：
```
[1] -> [1, 2] -> [1, 2, 3]
[2] -> [2, 3]
[3]

可用：nums, i
：res
：path
```

```python
    def subsets(self, nums):
        res = []
        # nums.sort()
        def dfs(nums, i, res, path):
            res.append(path[:])
            for i in range(i, len(nums)): # 从它所在下标的后一个元素开始
                path.append(nums[i])
                dfs(nums, i+1, res, path)
                path.pop()
        dfs(nums, 0, res, [])
        return res
```

## 90. Subsets II
原题：https://leetcode.com/problems/subsets-ii/
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:
```
Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```
分析：只需增加去重时的判断`j!=i && s[j] == s[j - 1](不是 j + 1, 可能索引越界，而j 不等于 i 已经能保证 j >= 1).
注意：需要先对原数组进行**降序排序**
```python
    def subsets(self, nums):
        res = []
        nums.sort()
        def dfs(nums, i, res, path):
            res.append(path[:])
            for j in range(i, len(nums)): #
                if j!=i and nums[j]==nums[j-1]:
                    continue
                path.append(nums[j])
                dfs(nums, j+1, res, path)
                path.pop()
        dfs(nums, 0, res, [])
        return res
```

# 全排列
对比数字的全排列和字符串的全排列，一种是假设没重复，**不修改可用ss而是每次判断ss中的元素**是否已经加到path，再把元素添加进去，修改path而不修改可用ss进行添加，后续remove
一种是可能有重复，所以不判断path中是否有该元素，而是**每次修改可用ss**，每个元素都会依次加进去，将最终结果去重
## 列表中数字的全排列
[LintCode 15. Permutations](https://www.lintcode.com/problem/permutations/description)
Given a list of numbers, return all possible permutations.

*You can assume that there is no duplicate numbers in the list.*

Example
Example 1:
```
Input: [1]
Output:
[
  [1]
]
```
Example 2:
```
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```
> 每次可用的nums不变，只是在判断时，如果path中已经有了这个元素，就不再添加。如果path中还没有这个元素，就把它加到path找那个，当达到[1, 2, 3]时，把path加到res中，dfs()语句会执行完，回到上一层函数，继续执行上一层函数体的下一行语句，这时要path.remove(nums[i])，才能复原从上一层函数进入这个可行解之前的状态。

```python
    def permute(self, nums):
        res = []
        # dfs核心
        def dfs(nums, res, path):
            if len(nums)==len(path):
                res.append(path[:])
            for i in range(len(nums)):
                if nums[i] not in path:
                    path.append(nums[i])
                    dfs(nums, res, path)
                    path.remove(nums[i])
        dfs(nums, res, [])
        return res
```
## 全排列 II
[LeetCode 47. Permutations II](https://leetcode.com/problems/permutations-ii/)
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:
```
Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```
分析：需要处理重复数字

```python
    def permutations(self, nums):
        res = []
        nums.sort()
        def dfs(nums, res, path):
            if not nums:
                res.append(path[:])
            for i in range(len(nums)):
                if i > 0 and nums[i-1] == nums[i]: #
                    continue
                dfs(nums[:i]+nums[i+1:], res, path+[nums[i]]) # 
        dfs(nums, res, [])
        return res
```
`dfs(nums[:i]+nums[i+1:], res, path+[nums[i]])`也可以拆分写成：
```python
path.append(nums[i])
dfs(nums[:i]+nums[i+1:])
path.pop()
```

## 字符串的全排列
[剑指Offer 27. 字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=2)
```python
    def sPermutation(self, ss):
        if not ss:
            return []
        res = []
        def dfs(ss, res, path):
            if not ss:
                res.append(path)
            for i in range(len(ss)):
                # 这里没在函数体里path + ，所以不用path -
                dfs(ss[:i]+ss[i+1:], res, path+ss[i])
        dfs(ss, res, '')
        return sorted(list(set(res))) # 去重，排序
```
如果把代码中dfs()换成下边这三行也是一样的
```python
# path = path + ss[i]
# dfs(ss[:i]+ss[i+1:], res, path)
# path = path[:len(path)-1]
```

# Combination Sum

Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:
```
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
```
Example 2:
```
Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

```
                []
   /        /           \       \         
   2        3            6       7
/ / \ \   / / \
2 3 6 7  3  6  7          ...      ...
...
避免重复
```

```python
class Solution(object):
    def combinationSum(self, candidates, target):
        res = []
        def dfs(nums, res, path, target, i):# i是开始元素的位置
            if target == 0:
                res.append(path[:])
            if target<0:
                return
            for j in range(i, len(nums)):
                dfs(nums, res, path+[nums[j]], target-nums[j], j)
        dfs(candidates, res, [], target, 0)
        return res
```

# 17. Letter Combinations of a Phone Number
https://leetcode.com/problems/letter-combinations-of-a-phone-number/
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![](/images/lc17.png)
Example:
```
Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.

分析：
- 边界：字符串为''时返回[]

```python
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        res = []
        s = []
        for ch in digits:
            if ch in digits:
                s.append(ch)
        if not s:
            return []
        # print('s',s)
        dic = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        
        def dfs(s, i, path, res):
            if i==len(s):
                res.append(path)
                return
            else:
                # print('s[i], dic[s[i]]', s[i], dic[s[i]])
                lst = dic[s[i]]
                for j in range(len(lst)):
                    dfs(s, i+1, path+lst[j], res)
        dfs(s, 0, '', res)
        return res
```