---
title: 算法题目分类题解
date: 2019-04-02 20:34:44ta
tag: 
- 算法题目总结
categories: 算法和数据结构
---

[[toc]]

# 动态规划
## Minimum Path Sum
原题：https://leetcode.com/problems/minimum-path-sum/
Given a `m x n` grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:
```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```
分析：dp，到达matrix[i][j]只能从它上边或者下边过来，用`dp[i][j]`表示到达`matrix[i][j]`的最小路径和。
- 初始，第0行和第0列的`dp`值为依次累加和
- 状态转移方程为：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]`

Runtime: 84 ms, faster than 37.22% 
```python
    def minSumPath(self, matrix):
        if not matrix:
            return 0
        M = len(matrix)
        N = len(matrix[0])
        dp = [[0 for j in range(N)] for i in range(M)]
        dp[0][0] = matrix[0][0]
        # 初始化
        for j in range(1, N):
            dp[0][j] = dp[0][j-1] + matrix[0][j]
        for i in range(1, M):
            dp[i][0] = dp[i-1][0] + matrix[i][0]
        # dp更新，只能从上边或下边到达
        for i in range(1, M):
            for j in range(1, N):
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]
        return dp[-1][-1]
```
## Minimum Falling Path Sum
原题：https://leetcode.com/problems/minimum-falling-path-sum/
Given a square array of integers A, we want the minimum sum of a falling path through A.

A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.

Example 1:
```
Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: 12
Explanation: 
The possible falling paths are:
[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
```
分析：下一行的元素所在列和它前一行的元素所在列最多相差1.
到达元素`A[i][j]`的最小路径和应该从`A[i - 1][j - 1]`，`A[i - 1][j]` ，`A[i - 1][j + 1]`三者之间选。如：
```
[1, 2, 3]
[4, 5, 6] => [5, 6, 8]
[7, 8, 9] => [7, 8, 9] => [12, 13, 15]
```
Runtime: 124 ms, faster than 32.91%
```python
    def minFallingPathSum(self, A):
        N = len(A)
        dp = [[0 for i in range(N)] for j in range(N)]
        for j in range(N):
            dp[0][j] = A[0][j]
        for i in range(1, N):
            for j in range(0, N):
                dp[i][j] = min(dp[i-1][max(j-1, 0)], dp[i-1][j],
                               dp[i-1][min(j+1, N-1)]) + A[i][j]
        return min(dp[-1]) 
```
## Minimum Cost For Tickets
原题：https://leetcode.com/problems/minimum-cost-for-tickets/
In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.

Train tickets are sold in 3 different ways:

a 1-day pass is sold for costs[0] dollars;
a 7-day pass is sold for costs[1] dollars;
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.

Return the minimum number of dollars you need to travel every day in the given list of days.

Example 1:
```
Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: 
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total you spent $11 and covered all the days of your travel.
```
Example 2:
```
Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation: 
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total you spent $17 and covered all the days of your travel.
```
Note:
```
1 <= days.length <= 365
1 <= days[i] <= 365
days is in strictly increasing order.
costs.length == 3
1 <= costs[i] <= 1000
```
分析：`dp[i]`表示到天数`i`所需的花费，如果第`i`天不需旅行，则它就等于`dp[i-1]`
状态转移方程：`dp[i] = min(dp[i-j]+cost[j])`，j可能是1天，7天，30天，`cost[j]`是旅行`j`天的花费

Runtime: 36 ms, faster than 46.86% 
```python
    def mincostTickets(self, days, costs):
        if not days or not costs:
            return 0
        N = len(days)
        print(N)
        dp = [0] * (days[-1]+1)
        for i in range(days[-1]+1):
            if i not in days:
                dp[i] = dp[i-1]
            else:
                dp[i] = min(dp[max(i-1, 0)]+costs[0],
                          dp[max(i-7, 0)]+costs[1], 
                          dp[max(i-30, 0)]+costs[2])
        return dp[-1]
```

## Arithmetic Slices
原题：https://leetcode.com/problems/arithmetic-slices/
A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequence:
```
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
```
The following sequence is not arithmetic.
```
1, 1, 2, 5, 7
```
A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.

A slice (P, Q) of array A is called arithmetic if the sequence:
A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.

The function should return the number of arithmetic slices in the array A.


Example:
```
A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
```
分析：找到A中是Arithmetic sequence的切片。
cuur是每次的累积次数，cnt是总次数
如`1 2 3 4 5`包含`1 2 3`,`2,3,4`,`3,4,5`,`1,2,3,4`,`2,3,4,5`,`1,2,3,4,5`共5种

Runtime: 28 ms, faster than 42.93%
```python
    def numberOfArithmeticSlices(self, A):
        curr = 0
        cnt = 0
        N = len(A)
        for i in range(2, N):
            if A[i]-A[i-1] == A[i-1]-A[i-2]:
                curr += 1
                cnt += curr
            else:
                curr = 0
        return cnt
```
## Coin Change
原题：https://leetcode.com/problems/coin-change/
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
```
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
```
Example 2:
```
Input: coins = [2], amount = 3
Output: -1
```
Note:
You may assume that you have an infinite number of each kind of coin.

分析：`dp[i]`表示凑出总和为i需要的硬币数，凑出总和i可以从已有coins中选
- 初始将dp值设为`aim+1`是为了更新`dp[i]`，最后需要判断dp[i]有没有凑出来，如果没有凑出来应该还是默认值`aim+1`，这时候要返回`-1`
- 状态转移方程：`dp[i]=1+min(dp[i-coin])`

Runtime: 1680 ms, faster than 14.80% 
```python
    def coinChange(self, arr, aim):
        if not arr:
            return -1
        if not aim:
            return 0
        N = len(arr)
        dp = [aim+1] * (aim+1)
        for i in range(1, aim+1):
            for coin in arr:
                if i==coin:
                    dp[i] = 1
                else:
                    dp[i] = min(dp[i], dp[max(i-coin, 0)]+1)
        return dp[-1] if dp[-1]!=(aim+1) else -1
```

## 最长递增子序列
原题：https://leetcode.com/problems/longest-increasing-subsequence/
Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:
```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```
Note:
There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
Follow up: Could you improve it to O(n log n) time complexity?

分析：最长递增子序列（中元素的个数）
思路1，设dp数组，每一次遍历到x，从后往前找 $dp[i]=max\{dp[j]+1(0<=j<i，arr[j]<arr[i])\}。$ dp[j]中数值最大的那个+1。

时间复杂度：O(n^2)
Runtime: 1084 ms, faster than 11.25%
```python
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        N = len(nums)
        dp = [1]*(N)
        for i in range(1, N):
            for j in range(i, -1, -1):
                if nums[i]>nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        # print(dp)
        return max(dp)
```

思路2：利用二分查找优化时间
**用一个数组ends保存最长递增序列为k的最小元素**，如
```
nums        2 1 5 3 6 4 8 9 7
dp          1 1 2 2 3 3 4 5 4

endsindex 0 1 2 3 4 5 6 7 8 9         
ends        1 3 4 7 9
```
>ends下标为k，表示原数组中最长递增序列长度为k的这些序列中，最小的元素是ends[k]。下标从1开始是为了方便。

初始，dp[0] = 1，ends[1] = nums[0]，right = 1（有效下标边界），当遍历nums中的数x时，在ends数组中利用二分查找第一个大于等于x的数（所在ends的下标l），**（如果ends中存在这样一个数，返回所在ends下标；如果不存在，则在right右边。不过最后的下标都是l）**

**找到l下标之后，更新ends[l]=x，更新dp[i]=l（l是ends下标即最长长度），更新right为max(l, right)**

时间复杂度O(nlogn)
Runtime: 32 ms, faster than 80.94%
```python
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        N = len(nums)
        dp = [0] * N
        ends = [0] * (N+1)
        right = 1
        dp[0] = 1
        ends[1] = nums[0]
        for i in range(1, N):# nums中的数字nums[i]
            #在ends里进行二分查找
            l, r = 1, right
            while l<=r:
                mid = (l+r)//2
                if ends[mid]<nums[i]:
                    l = mid+1
                else:
                    r = mid-1
            # l是那个位置
            ends[l] = nums[i] #更新ends[l]
            dp[i] = l #更新dp
            right = max(l, right) #更新right
        return max(dp)
```
## 最长公共子串问题

给定两个字符串 str1 和 str2，返回两个字符串的最长公共子串。
Example
```
str1="1AB2345CD"，str2="12345EF"，返回"2345"。
```
要求
如果 str1 长度为 M，str2 长度为 N，实现时间复杂度为 O(MN)，额外空间复杂度为 O(1)的方法。

分析：
思路1，。`dp[i][j]` 的含义是，在必须把 s`tr1[i]`和 `str2[j]`当作公共子串最后一个字符的情况下，公共子串最长有多长。
- 初始，以str1[0]结尾和以str2[j]结尾的dp值，就是str1中第0个字符是否在str2中出现，str2同理
- 状态转移方程：`dp[i][j]`的值只可能有两种情况。 
  - 如果 `str1[i]!=str2[j]`，说明在必须把 `str1[i]`和 `str2[j]`当作公共子串最后一个字符是不 可能的，令 `dp[i][j]`=0。
  - 如果 `str1[i]==str2[j]`，说明 `str1[i]`和 `str2[j]`可以作为公共子串的最后一个字符，从 最 后 一 个 字 符 向 左 能 扩 多 大 的 长 度 呢 ？ 就 是 `dp[i-1][j-1]` 的 值 ， 所 以 令 `dp[i][j]=dp[i-1][j-1]+1`
```python
    def longestCommonStr(self, s1, s2):
        '''
        时间复杂度 O(MN)
        空间复杂度 O(MN)
        '''
        if not s1 or not s2:
            return ''
        M = len(s1)
        N = len(s2)
        dp = [[0 for j in range(N)] for i in range(M)]
        for i in range(M):
            if s1[i] == s2[0]:
                dp[i][0] = 1
        for j in range(N):
            if s1[0] == s2[j]:
                dp[0][j] = 1
        endidx = 0
        maxlen = 0
        for i in range(1, M):
            for j in range(1, N):
                if s1[i]==s2[j]:
                    dp[i][j] = dp[i-1][j-1]+1
                    if dp[i][j]>maxlen:
                        maxlen = dp[i][j]
                        endidx = i
                else:
                    dp[i][j] = 0
        return s1[endidx+1-maxlen:endidx+1]
```

思路2，优化空间复杂度
![](/images/longestcommansequence.png)
row：行起始
col：列起始
i，j是在起始行为row和起始列为col的斜线的遍历

```python
    def longestCommonStr(self, s1, s2):
        '''
        时间复杂度 O(MN)
        空间复杂度 O(1)
        '''
        if not s1 or not s2:
            return ''
        M = len(s1)
        N = len(s2)
        # 全局
        maxlen = 0
        endidx = 0
        # 控制每个斜线的行和列的开始
        row = 0
        col = N-1
        
        while row<M: # 每次斜线开始
            i = row
            j = col
            tmplen = 0
            while i<M and j<N:
                if s1[i]!=s2[j]:
                    tmplen = 0
                else:
                    tmplen += 1
                if tmplen>maxlen:
                    maxlen = tmplen
                    endidx = i
                i += 1
                j += 1
            if col>0:
                col -= 1
            else:
                row += 1
        return s1[endidx+1-maxlen:endidx+1]
```
## 最长公共子序列问题
原题：https://www.lintcode.com/problem/longest-common-subsequence/description

Description
中文
English
Given two strings, find the longest common subsequence (LCS).

Your code should return the length of LCS.

Have you met this question in a real interview?  
Clarification
What's the definition of Longest Common Subsequence?

https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
http://baike.baidu.com/view/2020307.htm
Example
Example 1:
```
	Input:  "ABCD" and "EDCA"
	Output:  1
	
	Explanation:
	LCS is 'A' or  'D' or 'C'
```

Example 2:
```
	Input: "ABCD" and "EACB"
	Output:  2
	
	Explanation: 
	LCS is "AC"
```
最长公共子序列（LCS）是一个在一个序列集合中（通常为两个序列）用来查找所有序列中最长子序列的问题。这与查找最长公共子串的问题不同的地方是：子序列不需要在原序列中占用连续的位置。而最长公共子串（要求连续）和最长公共子序列是不同的。

分析：同样设置`dp[i][j]`表示字符串s1以字符s1[i]和字符串s2以字符s2[j]结尾得到的公共子序列
- 初始，第0行，如果s1[0]和s2[j]字符相等，则置为1；如果不等的话，若前边字符是相等的，也要置为1，如下所示，若`b`和`db`的公共子序列长度为1，则`b`和`dbe`的公共子序列长度也为1.Note：不要累加，`ee`和`e`的公共子序列长度是1
```
  d b e d
b 0 1 1 1
e 0
d 1
```
- 更新dp
`dp[i][j]`的值只可能来自以下三种情况:
    - 上边
    - 下边
    - 如果s1[i]==s2[j]还可能来自左上角，`dp[i-1][j-1] + 1`
这三种情况取最大值

Total runtime 101 ms
Your submission beats 99.80% Submissions!

```python
class Solution:
    """
    @param A: A string
    @param B: A string
    @return: The length of longest common subsequence of A and B
    """
    def longestCommonSubsequence(self, s1, s2):
        if not s1 or not s2:
            return 0
        M = len(s1)
        N = len(s2)
        dp = [[0 for j in range(N)] for i in range(M)]
        # dp初始
        if s1[0]==s2[0]:
            dp[0][0] = 1
        for j in range(1, N):
            if s1[0]==s2[j]:
                dp[0][j] = 1 #
            else:
                dp[0][j] = dp[0][j-1]
        for i in range(1, M):
            if s1[i]==s2[0]:
                dp[i][0] = 1 #
            else:
                dp[i][0] = dp[i-1][0]
        # 更新dp
        for i in range(1, M):
            for j in range(1, N):
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                if s1[i]==s2[j]:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1)
        return dp[-1][-1]
```
附加，返回最长的公共子序列，而不仅仅是长度。
```python
    def longestCommonSequence(self, s1, s2):
        if not s1 or not s2:
            return ''
        M = len(s1)
        N = len(s2)
        dp = [[0 for j in range(N)] for i in range(M)]
        # dp初始
        if s1[0]==s2[0]:
            dp[0][0] = 1
        for j in range(1, N):
            if s1[0]==s2[j]:
                dp[0][j] = 1 #
            else:
                dp[0][j] = dp[0][j-1]
        for i in range(1, M):
            if s1[i]==s2[0]:
                dp[i][0] = 1 #
            else:
                dp[i][0] = dp[i-1][0]
        # 更新dp
        for i in range(1, M):
            for j in range(1, N):
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                if s1[i]==s2[j]:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1)
        # 从后往前找最长公共子序列
        maxlen = dp[-1][-1]
        i, j = M-1, N-1
        res = ''
        print(maxlen)
        while maxlen>0:
            # 相等，是从左上角来的，还原回去
            if s1[i]==s2[j]:
                res = s1[i] + res
                i -= 1
                j -= 1
                maxlen -= 1
            # 不等，可能是从上边来的
            elif i>0 and dp[i][j]==dp[i-1][j]:
                i -= 1
            # 不等，也可能是从左边来的
            elif j>0 and dp[i][j]==dp[i][j-1]:
                j -= 1
        return res
```
## Best Time to Buy and Sell Stock with Cooldown
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:
```
Input: [1,2,3,0,2]
Output: 3 
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```
分析：设sell[i]为到i为止，从开头到最后一个以sell结尾，产生的最大利润。设buy[i]为到i为止，从开头到最后一个以buy结尾，产的最大利润。有
```python
buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);   
sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
```
这个问题的关键是<font color = red> 理解 buy[i]的含义</font>。

Runtime: 24 ms, faster than 81.58%
```python
    def maxProfit(self, prices):
        if len(prices)<2:
            return 0
        sell, buy, pre_sell, pre_buy = 0, -prices[0], 0, 0
        for price in prices:
            pre_buy = buy
            buy = max(pre_buy, pre_sell-price)
            pre_sell = sell
            sell = max(pre_sell, pre_buy+price)
        return sell
```

# 二叉树
## 二叉树的生成和遍历
```python
# 待修改为python
```
### 二叉树的结点类
```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {
        val = x;
    }
}
```
### 生成一棵二叉树
```java
public static void createBinaryTree(int[] arr, List<TreeNode> list){
    // 1.将数组中的数字都变成TreeNode节点，存到list中
    for (int i = 0; i < arr.length; i++) {
        list.add(new TreeNode(arr[i]));
    }

    // 2.编号为n的节点，他的左子节点编号为2*n+1，右子节点编号为2*n+2
    //   最后一个父节点有可能没有右子节点，需要单独处理
    for (int i = 0; i < arr.length/2-1; i++) {
        list.get(i).left = list.get(i*2+1);
        list.get(i).right = list.get(i*2+2);
    }

    // 3.单独处理最后一个父节点  因为它有可能没有右子节点
    //   如果有奇数个节点，最后一个父节点才有右子节点
    int index = arr.length/2-1;
    list.get(index).left = list.get(index*2+1);
    if(arr.length%2!=0)list.get(index).right = list.get(index*2+2);
}
```
### 先序、中序、后序递归遍历二叉树
```java
// 先序递归
public void preTra(Node node){
    if(node==null)return;
    preTra(node.leftChild);
    preTra(node.rightChild);
}
// 中序递归
public void inTra(Node node){
    if(node==null)return;
    inTra(node.leftChild);
    System.out.print(node.data+" ");
    inTra(node.rightChild);
}
// 后序递归
public void postTra(Node node){
    if(node==null)return;
    postTra(node.leftChild);
    postTra(node.rightChild);
    System.out.print(node.data+" ");
}
```
### 先序非递归遍历二叉树（利用栈）
```java
public void preOrder(TreeNode node){//用栈
    Stack<TreeNode> stack = new Stack<>();
    if(node==null)return;
    stack.push(node);
    while (!stack.empty()){
        TreeNode top = stack.pop();
        System.out.println(top.val);
        if(top.right!=null)stack.push(top.right);
        if(top.left!=null)stack.push(top.left);
    }
}
```
### 中序非递归遍历二叉树（利用栈）
***边界的考虑很巧妙** 直接利用stack和root是否均为空判断结束，并且一直只用root
```python
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        stack = []
        res = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop()
                res.append(root.val)
                root = root.right
        return res
```
### 后序非递归遍历二叉树（1.利用双栈）
![](/images/postorder.png)
```java
public void postOrder1(TreeNode node){
    if(node==null)return;
    Stack<TreeNode> stack1 = new Stack<>();
    Stack<TreeNode> stack2 = new Stack<>();
    stack1.push(node);
    while (!stack1.empty()){
        node = stack1.pop();
        stack2.push(node);
        if(node.left!=null)stack1.push(node.left);
        if(node.right!=null)stack1.push(node.right);
    }
    while (!stack2.empty()){
        System.out.println(stack2.pop().val);
    }
}
```
### 后序非递归遍历二叉树（2.利用先序遍历）
```java
// 后序非递归2，利用从右往左的先序遍历，最后反转
public void postOrder3(TreeNode node){
    if(node==null)return;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(node);
    List<Integer> list = new LinkedList<>();
    while (!stack.empty()){
        node = stack.pop();
        list.add(node.val);
        if(node.left!=null)stack.push(node.left);
        if(node.right!=null)stack.push(node.right);
    }
    Collections.reverse(list);
    for(int x:list)
        System.out.println(x);
}
```
### 二叉树的层次遍历（利用队列）
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        queue = []
        res = []
        out_size = 1
        in_size = 0
        queue.append(root)
        while queue:
            tmp = []
            while out_size:
                top = queue.pop(0)
                tmp.append(top.val)
                out_size -= 1
                if top.left:
                    queue.append(top.left)
                    in_size += 1
                if top.right:
                    queue.append(top.right)
                    in_size += 1
            res.append(tmp)
            out_size = in_size
            in_size = 0
        return res
```
### 二叉树的层次遍历——>进阶版：分层输出（利用队列）
```python
class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    def levelOrder(self, root):
        if not root:
            return []
        queue = []
        queue.append(root)
        out_cnt = 1
        in_cnt = 0
        res = []
        while queue:
            tmp = []
            while out_cnt > 0:
                out = queue[0]
                queue.pop(0)
                out_cnt -= 1
                tmp.append(out.val)
                if out.left:
                    queue.append(out.left)
                    in_cnt += 1
                if out.right:
                    queue.append(out.right)
                    in_cnt += 1
            out_cnt = in_cnt
            in_cnt = 0
            res.append(tmp)
        return res
```
###  二叉树的层次遍历——>进阶版：分层Z型输出（利用队列）
分析：和上边相比只是多了个flag
```python
        if not root:
            return []
        queue = []
        queue.append(root)
        out_cnt = 1
        in_cnt = 0
        res = []
        flag = True # True，从左往右，False，从右往左
        while queue:
            tmp = []
            while out_cnt > 0:
                out = queue[0]
                queue.pop(0)
                tmp.append(out.val)
                if out.left:
                    queue.append(out.left)
                    in_cnt += 1
                if out.right:
                    queue.append(out.right)
                    in_cnt += 1
                out_cnt -= 1
            out_cnt = in_cnt
            in_cnt = 0
            if flag:
                res.append(tmp)
            else:
                res.append(tmp[::-1])
            flag = not flag
        return res
```

## 二叉树的深度
https://leetcode.com/problems/maximum-depth-of-binary-tree/
分析：
```
终止条件：not root
终止返回值：看我需要什么

递归体：对于root这个节点来说，它的深度是：1+*左右子树中最大的深度*

```
```python
    def maxDepth(self, root):
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

## 两个任意节点间的最大距离
https://leetcode.com/problems/diameter-of-binary-tree/
分析：肯定是某个节点的左右子树深度之和
思路1，，一个时间复杂度很高的递归
```python
    def diameterOfBinaryTree(self, root):
        if not root:
            return 0
        L = self.getDepth(root.left)
        R = self.getDepth(root.right)
        return max(L+R, self.diameterOfBinaryTree(root.left), self.diameterOfBinaryTree(root.right))
    
    def getDepth(self, root):
        if not root:
            return 0
        return 1 + max(self.getDepth(root.left), self.getDepth(root.right))
```

思路2，优化，不需要调用两次递归，在计算深度的时候就顺便更新了~
```python
class Solution(object):
    def __init__(self):
        self.ans = 0
    def diameterOfBinaryTree(self, root):
        self.getDepth(root)
        return self.ans
        pass
    def getDepth(self, root):
        if not root:
            return 0
        L = self.getDepth(root.left)
        R = self.getDepth(root.right)
        self.ans = max(self.ans, L+R)
        return 1 + max(L, R)
```

## 两个节点的最近公共祖先节点
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
分析：对每个节点，在左右子树搜索p和q节点
```
    root
    /   \
left    right

root.left表示，root的左子树的根节点
left = self.lowestCommonAncestor(root.left, p, q)表示，在root的左子树中搜索p、q节点，如果搜到了，left就是这个左子树的根节点。

需要明确，如果在左子树搜到了，那么left是搜到的p或q节点的父节点。

而如果两个都搜到了，root是公共祖先。
```

```python
    def lowestCommonAncestor(self, root, p, q):
        '''最低公共祖先节点
        '''
        if root==p or root==q:
            return root
        left = right = None
        if root.left:
            left = self.lowestCommonAncestor(root.left, p, q) 
            
        if root.right:
            right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        return left if left else right
```

## 二叉树的镜像
https://leetcode.com/problems/symmetric-tree/
```python
    def isSymmetric(self, root):
        return self.isSym(root, root)

    def isSym(self, rootA, rootB):
        if not rootA and not rootB:
            return True
        if not rootA or not rootB:
            return False
        if rootA.val!=rootB.val:
            return False
        return self.isSym(rootA.left, rootB.right) and self.isSym(rootA.right, rootB.left)
```
## 合并两棵二叉树
https://leetcode.com/problems/merge-two-binary-trees/

```python
    def mergeTrees(self, t1, t2):
        if not t1 and not t2:
            return None
        if not t1:
            return t2
        if not t2:
            return t1
        root = TreeNode(t1.val + t2.val)
        root.left = self.mergeTrees(t1.left, t2.left)
        root.right = self.mergeTrees(t1.right, t2.right)
        return root  
```
## 翻转二叉树
https://leetcode.com/problems/invert-binary-tree/
```python
    def invertTree(self, root):
        def recursive(A):
            if not A:
                return None
            root = TreeNode(A.val)
            root.left = recursive(A.right)
            root.right = recursive(A.left)
            return root
        return recursive(root)
```

## 判断平衡二叉树
LeetCode 110. Balanced Binary Tree
https://leetcode.com/problems/balanced-binary-tree/submissions/

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example 1:
```
Given the following tree [3,9,20,null,null,15,7]:

    3
   / \
  9  20
    /  \
   15   7
Return true.
```
Example 2:
```
Given the following tree [1,2,2,3,3,null,null,4,4]:

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
```
分析：判断一个树是不是平衡二叉树，就是判断是不是每个节点的左右子树的高度之差的绝对值小于等于1
求高度已经会用递归求了，接下来就是对每个节点递归求左右子树的高度，加个判断。

```python
    def getDepth(self, root):
        if not root:
            return 0
        return 1+max(self.getDepth(root.left), self.getDepth(root.right))

    def isBalanced(self, root):
        if not root:
            return True
        leftHeight = self.getDepth(root.left)
        rightHeight = self.getDepth(root.right)
        if abs(leftHeight-rightHeight)>1:
            return False
        else:
            return self.isBalanced(root.left) and self.isBalanced(root.right) 
```


Runtime: 32 ms, faster than 99.77% 
## 判断两个树是否相同
https://leetcode.com/problems/same-tree/
Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Example 1:
```
Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
```
Example 2:
```
Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
```
Example 3:
```
Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
```
分析：递归检查即可。直到最后两个树都为空时才return True，否则一直递归比较两个树的左右节点。

Runtime: 12 ms, faster than 46.6%
```python
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        if not p and not q:
            return True
        if not p or not q:
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
分析优化：整棵树有很多冗余无意义的遍历，其实我们在处理完getDepth这个高度的时候，我们完全可以在检查每个节点高度并且返回的同时，记录左右差是否已经超过1，只要有一个节点超过1，那么直接返回False即可，因此我们只需要在外围设立一个全局变量记录True和False，在调用getDepth的时候，内置代码里加入对左右高度的判定即可

优化之后
Runtime: 12 ms, faster than 99.93%
```python
    def __init__(self):
        self.is_balance = True
        
    def getDepth(self, root):
        if not root:
            return 0
        left = self.getDepth(root.left)
        right = self.getDepth(root.right)
        if abs(left-right) > 1:
            self.is_balance = False
        
        return max(left, right)+1

    def isBalanced(self, root):
        if not root:
            return True
        self.getDepth(root)
        return self.is_balance
```


## convertBST
https://leetcode.com/problems/convert-bst-to-greater-tree/
```python
    def __init__(self):
        self.sum = 0

    def convertBST(self, root):
        '''利用中序遍历的逆序，这样可以累加
        '''
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return None
        self.convertBST(root.right)
        tmp = root.val
        root.val += self.sum
        self.sum += tmp
        self.convertBST(root.left)
        return root
```

## Path Sum 
https://leetcode.com/problems/path-sum/
```python
    def hasPathSum(self, root, target):
        '''是否存在 root-to-leaf
        '''
        def dfs(root, target):
            if not root:
                return False
            if not root.left and not root.right and root.val==target:
                return True
            return dfs(root.left, target-root.val) or dfs(root.right, target-root.val)
        return dfs(root, target)
```
## Path Sum
https://leetcode.com/problems/path-sum-ii/

**Path Sum II. root-to-leaf**

之前错在了：先`path.append(root.val)`，然后对左右子树进行dfs，最后再`path.pop()`，这样不对，因为从左子树出来进右子树时也要还原
所以最好把path的更新写在对左右子树的dfs里

```python
    def pathSum(self, root, target):
        ''' root-to-leaf 节点记录到res列表中
        '''
        res = []
        def dfs(root, res, path, target):
            if not root:
                return
            if not root.left and not root.right and target == root.val: # 前边两个判断保证是叶子节点 
                res.append(path+[root.val])
            dfs(root.left, res, path+[root.val], target-root.val)
            dfs(root.right, res, path+[root.val], target-root.val)
        dfs(root, res, [], target)
        return res
```
## Path Sum III
https://leetcode.com/problems/path-sum-iii/
```python
    def pathSum(self, root, target):
        ''' 不必从root开始或从leaf结束，但一定要从上边节点到下边节点
        The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
        '''
        if not root:
            return 0
        def dfs(root, target):
            res = 0
            if not root:
                return 0
            if target == root.val:  # PathSum不要求是叶子节点
                res += 1
            res += dfs(root.left, target-root.val)
            res += dfs(root.right, target-root.val)
            return res
        result = dfs(root, target) \
            + self.pathSum(root.left, target) \
            + self.pathSum(root.right, target)
        return result
```
## Sum of Root To Leaf Binary Numbers 
https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/

Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.

Return the sum of these numbers.

 

Example 1:
![](/images/lc1022.png)
```
Input: [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
``` 
Note:
```
The number of nodes in the tree is between 1 and 1000.
node.val is 0 or 1.
The answer will not exceed 2^31 - 1.
```
分析：dfs得到所有root-to-leaf的路径，然后转换。
但其实你可以在dfs过程中进行转换，不再用path存路径，而是用整数tmp，每次tmp*2加上新值

beats 100%
```python
    def sumRootToLeaf(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        res = []
        def dfs(root, res, tmp):
            if not root:
                return
            if not root.left and not root.right:
                res.append(tmp*2+root.val)
                return
            dfs(root.left, res, tmp*2+root.val)
            dfs(root.right, res, tmp*2+root.val)
        dfs(root, res, 0)
        return sum(res)
```


## Convert Sorted Array to Binary Search Tree
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:
```
Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```
分析：肯定是用到递归，设计一个函数：根据nums数组中间的元素返回一个根节点。对于原数组产生的根节点root，root.left是对左半部分数组产生根节点，root.right是对右半部分数组产生根节点，对每个节点都做同样的操作。

beats 60%
```python
    def sortedArrayToBST(self, nums):
        if not nums:
            return None
        root = self.roots(nums)
        idx = nums.index(root.val)
        root.left = self.sortedArrayToBST(nums[:idx])
        root.right = self.sortedArrayToBST(nums[idx+1:])
        return root

    def roots(self, nums):
        if not nums:
            return None
        return TreeNode(nums[(len(nums)-1)//2])
```

## Minimum Absolute Difference in BST
https://leetcode.com/problems/minimum-absolute-difference-in-bst/submissions/

Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.

Example:

```
Input:

   1
    \
     3
    /
   2

Output:
1

Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).
```

分析：题目是BST中任意两个节点中差的绝对值最小的。利用BST的性质，进行中序遍历，每次把root的前一数字存起来，并更新dif。

Runtime: 36 ms, faster than 100.00% 

```python
    def __init__(self):
        self.dif = 10000
        self.preNumber = -10000

    def getMinimumDifference(self, root):
        return self.inTraverse(root)
        
    # inorder traverse and update dif and preNumber
    def inTraverse(self, root):
        if not root:
            return
        self.inTraverse(root.left)
        self.dif = min(self.dif, root.val-self.preNumber)
        self.preNumber = root.val
        self.inTraverse(root.right)
        return self.dif
```
## 左叶子节点的和
https://leetcode.com/problems/sum-of-left-leaves/
Find the sum of all left leaves in a given binary tree.

Example:
```
    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
```

分析：先序遍历（其它的遍历方式也可以），判断如果是左叶子节点则加到self.sum中去
Runtime: 24 ms, faster than 76.49%
```python
    def __init__(self):
        self.sum_lc404  = 0
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def preTraverse(root):
            if not root:
                return
            if root.left:
                if not root.left.left and not root.left.right:
                    self.sum_lc404 += root.left.val
                preTraverse(root.left)
            preTraverse(root.right)
        preTraverse(root)
        return self.sum_lc404
```
## 打印所有的root-to-leaf的路径
https://leetcode.com/problems/binary-tree-paths/
Given a binary tree, return all root-to-leaf paths.

Note: A leaf is a node with no children.

Example:
```
Input:

   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]

Explanation: All root-to-leaf paths are: 1->2->5, 1->3
```

分析：用dfs，注意打印的格式需要加个判断

Runtime: 24 ms, faster than 81.06%
```python
    def binaryTreePaths(self, root):
        res = []
        def dfs(root, res, s):
            if not root:
                return
            if s != '':
                s = s+'->'+str(root.val)
            else:
                s = s+str(root.val)
            if not root.left and not root.right:#如果是叶子节点
                res.append(s)
                return
            dfs(root.left, res, s)
            dfs(root.right, res, s)
        dfs(root, res, '')
        return res
```
## Binary Tree Tilt
https://leetcode.com/problems/binary-tree-tilt/submissions/

Given a binary tree, return the tilt of the whole tree.

The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.

The tilt of the whole tree is defined as the sum of all nodes' tilt.

Example:
```
Input: 
         1
       /   \
      2     3
Output: 1
Explanation: 
Tilt of node 2 : 0
Tilt of node 3 : 0
Tilt of node 1 : |2-3| = 1
Tilt of binary tree : 0 + 0 + 1 = 1
```
Note:

The sum of node values in any subtree won't exceed the range of 32-bit integer.
All the tilt values won't exceed the range of 32-bit integer.

分析：题目大意，每个节点的tilt是它的左右子树的差的绝对值，求所有节点的tilt之和。
一个思维上的trick就是，利用后序遍历，自底向上计算左右子树和根的值。

Runtime: 44 ms, faster than 100.00% 

```python
    def __init__(self):
        self.result_lc563 = 0
    def findTilt(self, root):
        def postTraverse(root):
            if not root:
                return 0
            left = postTraverse(root.left)
            right = postTraverse(root.right)
            self.result_lc563 += abs(right-left)
            return left+right+root.val
        postTraverse(root)
        return self.result_lc563
```
## 找到二叉树出现次数最多的节点

Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.
 

For example:
Given BST [1,null,2,2],
```
   1
    \
     2
    /
   2
 
```
return [2].

Note: If a tree has more than one mode, you can return them in any order.

Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).

分析：要找到BST中出现次数最多的节点，直观思路就是先确定最大的次数maxcnt，再把出现次数为cnt的节点加到res中。
一、先中序遍历确定最大次数maxcnt，并且存到dic中，更进一步存到counter里；再获取counter中次数为maxcnt的key添加到res
二、中序遍历过程中记录tempCnt，并实时更新maxCnt，并记录前一个节点的值。当不相等的时候，判断tempCnt和maxCnt的关系，如果tempCnt>maxCnt，就要移除res列表中添加了的元素，添加次数最多的这个；如果tempCnt==maxCnt，就直接把元素加到res中。如果小于则不添加，直接修改相应的值就好了。

参考：
https://blog.csdn.net/fuxuemingzhu/article/details/71124600
https://www.liuchuo.net/archives/3174

Runtime: 44 ms, faster than 99.18% 
```python
from collections import Counter
class Solution(object):
    def findMode(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        res = []
        self.dic = {}
        def inTraverse(root):
            if not root:
                return
            inTraverse(root.left)
            if root.val in self.dic:
                self.dic[root.val] += 1
            else:
                self.dic[root.val] = 1
            inTraverse(root.right)
        inTraverse(root)
        counter = Counter(self.dic)
        maxcnt = max(counter.values())
        for i, c in counter.items():
            if c==maxcnt:
                res.append(i)
        return res
```
不使用额外的空间，修改之后
Runtime: 40 ms, faster than 100.00%
```python
    def findMode(self, root):
        if not root:
            return []
        self.maxcnt = 0
        self.tmpcnt = 0
        self.res = []
        self.preval = root.val

        def inTraverse(root):
            if not root:
                return
            inTraverse(root.left)
            self.tmpcnt += 1
            if root.val!=self.preval:# 不等于了
                self.preval = root.val
                self.tmpcnt = 1
            if self.tmpcnt>self.maxcnt:
                self.maxcnt = self.tmpcnt
                self.res = []
                self.res.append(self.preval)
            elif self.tmpcnt == self.maxcnt:
                self.res.append(self.preval)
            inTraverse(root.right)

        inTraverse(root)
        return self.res
```

# 链表
## 在O(1)时间复杂度删除链表节点
https://leetcode.com/problems/delete-node-in-a-linked-list/
题目描述：给定一个单链表中的表头和一个等待被删除的节点(非表头或表尾)。请在在O(1)时间复杂度删除该链表节点。并在删除该节点后，返回表头。

样例：给定 1->2->3->4，和节点 3，返回 1->2->4。

分析：题目中给定了要删除的节点node，只需要获得node.next这个节点，然后把node的val和next更新为它的next对应的值。即
```
node.val = node.next.val
node.next = node.next.next
```
注意：这种方法只适用于不是头结点或尾结点的情况，如果不是这两种情况，还是需要用传统方法从头往后遍历。不过呢，这种方法的平均时间复杂度还是O(1),(O(1)*n+O(n))/n = O(1) haha

```python
    def deleteNode(self, node):
        '''删除链表中的节点（不含尾结点）
        '''
        node.val = node.next.val
        node.next = node.next.next
```

## 反转链表
https://leetcode.com/problems/reverse-linked-list/
无环哦
```python
    def reverseList(self, head):
        '''反转链表
        '''
        if not head:
            return None
        pre = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```
## 判断链表是否有环
```python
    def hasCycle(self, head):
        '''判断链表是否有环
        '''
        if not head or not head.next:
            return False
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        if not fast or not fast.next:
            return False
        else:
            return True
```

## 环形链表的入口节点
https://leetcode.com/problems/linked-list-cycle-ii/

```python
class Solution(object):
    def detectCycle(self, head):
        """
        环形链表的入口节点
        :type head: ListNode
        :rtype: ListNode
        """
        def hasCircle(head):
            if not head or not head.next:
                return None
            slow = head
            fast = head
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
                if slow==fast:
                    break
            if not fast or not fast.next:
                return None
            else:
                return fast
        meetNode = hasCircle(head)
        if not meetNode:
            return None
        cur = head
        while cur!=meetNode:
            cur = cur.next
            meetNode = meetNode.next
        return cur
```
## 两个链表的公共节点
https://leetcode.com/problems/intersection-of-two-linked-lists/
```python
    def getIntersectionNode(self, headA, headB):
        '''两个链表的公共节点
        '''
        if not headA or not headB:
            return None
        curA = headA
        curB = headB
        while curA!=curB:
            curA = curA.next if curA else headB
            curB = curB.next if curB else headA
        return curA
```

## 链表的中间节点
https://leetcode.com/problems/middle-of-the-linked-list/
```python
    def middleNode(self, head):
        '''链表的中间节点 利用快慢指针
        0->1->2->3    返回2
        0->1->2->3->4 返回2
        '''
        if not head:
            return None
        if not head.next:
            return head
        slow = head
        fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
```

## 判断回文链表
https://leetcode.com/problems/palindrome-linked-list/

```python
    def isPalindrome(self, head):
        '''判断回文链表  
        找到中间节点的过程中反转左半部分的链表
        然后比较左右
        '''
        if not head or not head.next:
            return True
        pre, slow, fast = None, head, head
        while fast and fast.next:
            fast = fast.next.next
            nxt = slow.next
            slow.next = pre
            pre = slow
            slow = nxt
        # 最后，slow仍是中间节点2，它的next指向还没来得及变
        # 所以pre是前一个节点，如果是奇数个节点，slow需要后移到3
        if fast:                # 这里不写成if not fast.next的原因是：如果偶数个节点时fast为None
            slow = slow.next
        while slow and pre:
            if slow.val!=pre.val:
                return False
            slow = slow.next
            pre = pre.next
        return True
```

## 合并两个有序链表
https://leetcode.com/problems/merge-two-sorted-lists/

非递归
```python
    def mergeTwoLists(self, l1, l2):
        dummy = cur = ListNode(-1)
        while l1 and l2:
            if l1.val<=l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        cur.next = l1 or l2
        return dummy.next
```

递归
```python
    def mergeTwoLists(self, l1, l2):
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val<l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

# 回溯
网上很多文章都说到了这种思想，[参考](http://www.voidcn.com/article/p-phdmgdjq-gz.html)
回溯法有“通用的解题法”之称。用它可以系统地搜索一个问题的所有解或任一解。回溯法是一个既带有系统性又带有跳跃性的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。算法搜索至解空间树的任一节点时，总是先判断该节点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的系统搜索，逐层向其祖先节点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根节点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可结束。这种以深度优先的方式系统地搜索问题的解算法称为回溯法，它适用于解一些组合数较大的问题。

参考复习回溯的思想很好理解，如果画图你肯定知道是怎么回事，**关键在于代码的实现**

使用回溯法的一般步骤：

1. 确定所给问题的解空间：首先应明确定义问题的解空间，解空间中至少包含问题的一个解。
2. 确定结点的扩展搜索规则
3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

回溯题目：
1. 子集
2. 子集 II （含重复）
3. 数字的全排列
4. 数字的全排列 II（含重复）
5. 字符串的全排列

## 子集
### 78. Subsets
原题：https://leetcode.com/problems/subsets/
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:
```
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```
分析：
```
[1] -> [1, 2] -> [1, 2, 3]
[2] -> [2, 3]
[3]

可用：nums, i
：res
：path
```

```python
    def subsets(self, nums):
        res = []
        # nums.sort()
        def dfs(nums, i, res, path):
            res.append(path[:])
            for i in range(i, len(nums)): # 从它所在下标的后一个元素开始
                path.append(nums[i])
                dfs(nums, i+1, res, path)
                path.pop()
        dfs(nums, 0, res, [])
        return res
```

### 90. Subsets II
原题：https://leetcode.com/problems/subsets-ii/
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:
```
Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```
分析：只需增加去重时的判断`j!=i && s[j] == s[j - 1](不是 j + 1, 可能索引越界，而j 不等于 i 已经能保证 j >= 1).
注意：需要先对原数组进行**降序排序**
```python
    def subsets(self, nums):
        res = []
        nums.sort()
        def dfs(nums, i, res, path):
            res.append(path[:])
            for j in range(i, len(nums)): #
                if j!=i and nums[j]==nums[j-1]:
                    continue
                path.append(nums[j])
                dfs(nums, j+1, res, path)
                path.pop()
        dfs(nums, 0, res, [])
        return res
```

## 全排列
对比数字的全排列和字符串的全排列，一种是假设没重复，**不修改可用ss而是每次判断ss中的元素**是否已经加到path，再把元素添加进去，修改path而不修改可用ss进行添加，后续remove
一种是可能有重复，所以不判断path中是否有该元素，而是**每次修改可用ss**，每个元素都会依次加进去，将最终结果去重
### 列表中数字的全排列
[LintCode 15. Permutations](https://www.lintcode.com/problem/permutations/description)
Given a list of numbers, return all possible permutations.

*You can assume that there is no duplicate numbers in the list.*

Example
Example 1:
```
Input: [1]
Output:
[
  [1]
]
```
Example 2:
```
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```
> 每次可用的nums不变，只是在判断时，如果path中已经有了这个元素，就不再添加。如果path中还没有这个元素，就把它加到path找那个，当达到[1, 2, 3]时，把path加到res中，dfs()语句会执行完，回到上一层函数，继续执行上一层函数体的下一行语句，这时要path.remove(nums[i])，才能复原从上一层函数进入这个可行解之前的状态。

```python
    def permute(self, nums):
        res = []
        # dfs核心
        def dfs(nums, res, path):
            if len(nums)==len(path):
                res.append(path[:])
            for i in range(len(nums)):
                if nums[i] not in path:
                    path.append(nums[i])
                    dfs(nums, res, path)
                    path.remove(nums[i])
        dfs(nums, res, [])
        return res
```
### 全排列 II
[LeetCode 47. Permutations II](https://leetcode.com/problems/permutations-ii/)
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:
```
Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```
分析：需要处理重复数字

```python
    def permutations(self, nums):
        res = []
        nums.sort()
        def dfs(nums, res, path):
            if not nums:
                res.append(path[:])
            for i in range(len(nums)):
                if i > 0 and nums[i-1] == nums[i]: #
                    continue
                dfs(nums[:i]+nums[i+1:], res, path+[nums[i]]) # 
        dfs(nums, res, [])
        return res
```
`dfs(nums[:i]+nums[i+1:], res, path+[nums[i]])`也可以拆分写成：
```python
path.append(nums[i])
dfs(nums[:i]+nums[i+1:])
path.pop()
```

### 字符串的全排列
[剑指Offer 27. 字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=2)
```python
    def sPermutation(self, ss):
        if not ss:
            return []
        res = []
        def dfs(ss, res, path):
            if not ss:
                res.append(path)
            for i in range(len(ss)):
                # 这里没在函数体里path + ，所以不用path -
                dfs(ss[:i]+ss[i+1:], res, path+ss[i])
        dfs(ss, res, '')
        return sorted(list(set(res))) # 去重，排序
```
如果把代码中dfs()换成下边这三行也是一样的
```python
# path = path + ss[i]
# dfs(ss[:i]+ss[i+1:], res, path)
# path = path[:len(path)-1]
```

## Combination Sum

Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:
```
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
```
Example 2:
```
Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

```
                []
   /        /           \       \         
   2        3            6       7
/ / \ \   / / \
2 3 6 7  3  6  7          ...      ...
...
避免重复
```

```python
class Solution(object):
    def combinationSum(self, candidates, target):
        res = []
        def dfs(nums, res, path, target, i):# i是开始元素的位置
            if target == 0:
                res.append(path[:])
            if target<0:
                return
            for j in range(i, len(nums)):
                dfs(nums, res, path+[nums[j]], target-nums[j], j)
        dfs(candidates, res, [], target, 0)
        return res
```

## 17. Letter Combinations of a Phone Number
https://leetcode.com/problems/letter-combinations-of-a-phone-number/
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![](/images/lc17.png)
Example:
```
Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.

分析：
- 边界：字符串为''时返回[]

```python
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        res = []
        s = []
        for ch in digits:
            if ch in digits:
                s.append(ch)
        if not s:
            return []
        # print('s',s)
        dic = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        
        def dfs(s, i, path, res):
            if i==len(s):
                res.append(path)
                return
            else:
                # print('s[i], dic[s[i]]', s[i], dic[s[i]])
                lst = dic[s[i]]
                for j in range(len(lst)):
                    dfs(s, i+1, path+lst[j], res)
        dfs(s, 0, '', res)
        return res
```

# BFS
## Rotting Oranges
In a given grid, each cell can have one of three values:

the value 0 representing an empty cell;
the value 1 representing a fresh orange;
the value 2 representing a rotten orange.
Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.

Example 1:
![](/images/lc994oranges.png)
```
Input: [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
```
Example 2:
```
Input: [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
```
Example 3:
```
Input: [[0,2]]
Output: 0
Explanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.
```

分析：利用队列进行广度优先搜索，也就是类似树的层次遍历
```python
class Solution(object):
    def orangesRotting(self, grid):
        if not grid:
            return -1
        queue = []
        fresh_cnt = 0
        in_size = 0
        count = 0
        M = len(grid)
        N = len(grid[0])
        for i in range(M):
            for j in range(N):
                if grid[i][j] == 1:
                    fresh_cnt += 1
                elif grid[i][j] == 2:
                    queue.append([i, j])
        out_size = len(queue)
        if out_size == 0 and fresh_cnt!=0:
            return -1
        if out_size==0 and fresh_cnt==0:
            return 0
        if out_size!=0 and fresh_cnt==0:
            return 0
        while queue:
            # print(queue)
            count += 1
            while out_size: # 出队已经腐烂的，入队的是本次队列里可以感染的
                top = queue[0]
                queue.pop(0)
                out_size -= 1
                if self.checkBoundary(top[0], top[1]-1, M, N) and grid[top[0]][top[1]-1]==1:
                    fresh_cnt -= 1
                    queue.append([top[0], top[1]-1])
                    grid[top[0]][top[1]-1] = 2
                    in_size += 1
                if self.checkBoundary(top[0], top[1]+1, M, N) and grid[top[0]][top[1]+1] == 1:
                    fresh_cnt -= 1
                    queue.append([top[0], top[1]+1])
                    grid[top[0]][top[1]+1] = 2
                    in_size += 1
                if self.checkBoundary(top[0]-1, top[1], M, N) and grid[top[0]-1][top[1]] == 1:
                    fresh_cnt -= 1
                    queue.append([top[0]-1, top[1]])
                    grid[top[0]-1][top[1]] = 2
                    in_size += 1
                if self.checkBoundary(top[0]+1, top[1], M, N) and grid[top[0]+1][top[1]] == 1:
                    fresh_cnt -= 1
                    queue.append([top[0]+1, top[1]])
                    grid[top[0]+1][top[1]] = 2
                    in_size += 1
            out_size = in_size
            in_size = 0
        # print(fresh_cnt)
        # print(fresh_cnt2)
        # print(count)
        if fresh_cnt>0:
            return -1
        else:
            return count-1

    def checkBoundary(self, i, j, M, N):
        if i>=0 and i<M and j>=0 and j<N:
            return True
        else:
            return False
```

# 排序
## 冒泡排序
- N个数共需比较N-1趟，i为趟数
- 每一趟确定尚未排序的序列中最大的数字，所以随着趟数的增加，未排序的数字减少。

如：12 35 99 18 76
第0趟：12 35 18 76 **99**
第1趟：12 18 35 **76** **99**
...
第i趟，j和j-1的数字比较，j从[1, N-i)

<font color=red>代码</font>  
边界处理：arr为[]   
（N==1时不会进入循环，直接返回arr）

```python
	def bubble_sort(self, arr):
		if not arr:
			return []
		N = len(arr)
		for i in range(N-1):
			for j in range(1, N-i):
				if arr[j-1]>arr[j]:
					arr[j-1], arr[j] = arr[j], arr[j-1]
		return arr
```

<font color=red>测试用例</font>  
```
[1]
[1]

[6, 1, 2, 7, 9, 3, 4, 5, 10, 8]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

## 选择排序

- 第i趟确定第i个最小的元素
如：12 35 99 18 76
第0趟：**12** 35 18 76 99
第1趟：**12** **18** 35 76 99
...
第i趟，先把这一趟的最小值下标minidx设为i，然后minidx和i之后的每个元素进行比较更新

选择排序:
```python
for i in range(N-1):
	minidx = i
	for j in range(i+1, N):
```

冒泡排序：

```python
for i in range(N-1):
	for j in range(1, N-i):
```
边界处理：arr为[]   
（N==1时不会进入循环，直接返回arr）

```python
	def select_sort(self, arr):
		if not arr:
			return []
		N = len(arr)
		for i in range(N-1):
			minidx = i
			for j in range(i+1, N):
				if arr[j]<arr[minidx]:
					minidx = j
			arr[i], arr[minidx] = arr[minidx], arr[i]
		return arr
```
测试用例：

```
[1]
[1]

[6, 1, 2, 7, 9, 3, 4, 5, 10, 8]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

## 快排
上一节的冒泡排序可以说是我们学习第一个真正的排序算法，并且解决了桶排序浪费空间的问题，但在算法的执行效率上却牺牲了很多，它的时间复杂度达到了O(N2)。假如我们的计算机每秒钟可以运行10亿次，那么对1亿个数进行排序，桶排序则只需要0.1秒，而冒泡排序则需要1千万秒，达到115天之久，是不是很吓人。那有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。
 
假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列。
3  1  2 5  4  6  9 7  10  8

在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？

给你一个提示吧。请回忆一下冒泡排序，是如何通过“交换”，一步步让每个数归位的。此时你也可以通过“交换”的方法来达到目的。具体是如何一步步交换呢？怎样交换才既方便又节省时间呢？先别急着往下看，拿出笔来，在纸上画画看。我高中时第一次学习冒泡排序算法的时候，就觉得冒泡排序很浪费时间，每次都只能对相邻的两个数进行比较，这显然太不合理了。于是我就想了一个办法，后来才知道原来这就是“快速排序”，请允许我小小的自恋一下(^o^)。

方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即j=10），指向数字8。

首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j--），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。

现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下。
6  1  2  5  9 3  4  7  10  8
到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。
6  1  2 5  4  3  9  7 10  8

第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下。
3  1 2  5  4  6  9 7  10  8

到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。

OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。

左边的序列是“3  1  2 5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧。

如果你模拟的没有错，调整完毕之后的序列的顺序应该是。
2  1  3  5  4

OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下。
1  2  3 4  5  6 9  7  10  8

对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。
1  2  3 4  5  6  7  8 9  10

到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。


快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。

```python
	def quickSort(self, arr, i, j):
		if i>j:
			return
		low = i
		high = j
		key = arr[low]
		while i<j:
                    #注意，这里要有等号，因为碰到相等的不用交换，小于和大于才交换，否则出错
			while i<j and arr[j]>=key:
				j -= 1
			while i<j and arr[i]<=key:
				i += 1
			# 定下了j, i
			if i<j:
				arr[i], arr[j] = arr[j], arr[i]
				continue
			if i==j:
				arr[j], arr[low] = arr[low], arr[j]
				break
		self.quickSort(arr, low, i-1)
		self.quickSort(arr, i+1, high)
```

## 归并排序
- 为了让数组S有序，先把数组S拆分成A、B两个数组，将A、B变成有序数组，然后再将两个有序数组A、B合并，直到A、B中只有一个元素，那么它肯定是有序的。
- 这过程中，使A、B有序又是处理S的问题规模不同的相同问题，怎么处理S的就怎么处理A、B
- 一个主函数merge_sort()，一个用于将两个有序数组合并为一个有序数组merge_ab()

代码：
```python
	def merge_sort(self, arr):
		'''归并排序
		'''
		if len(arr)<=1:
			return arr
		mid = len(arr)//2
		A = self.merge_sort(arr[:mid])
		B = self.merge_sort(arr[mid:])
		return self.merge_ab(A, B)		


	def merge_ab(self, a, b):
		'''合并两个有序list
		'''
		c = []
		M, N = len(a), len(b)
		i, j = 0, 0

		while i<M and j<N:
			if a[i]<=b[j]:
				c.append(a[i])
				i += 1
			elif a[i]>b[j]:
				c.append(b[j])
				j += 1
		if i==M:
			for num in b[j:]:
				c.append(num)
		elif j==N:
			for num in a[i:]:
				c.append(num)
		return c
```
测试用例：
```
[]
[]

[1]
[1]

[6, 1, 2, 7, 9, 3, 4, 5, 10, 8]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

# 数组
## Two Sum
https://leetcode.com/problems/two-sum/
```python
    def twoSum_1(self, nums, target):
        '''利用哈希
        O(n)
        '''
        if not nums:
            return []
        dic = {}
        for i in range(len(nums)):
            if nums[i] not in dic:
                dic[target-nums[i]] = i
            else:
                return [dic[nums[i]], i]
    
    def twoSum_2(self, nums, target):
        '''先排序，再左右指针
        不过这种方法只能返回元素值,而不能得到下标
        O(nlogn) = O(nlogn)+O(n)
        '''
        if not nums:
            return []
        nums.sort()
        i, j = 0, len(nums)-1
        while i<j: #首尾指针，不能等于
            if nums[i]+nums[j]<target:
                i += 1
            elif nums[i]+nums[j]>target:
                j -= 1
            else:
                return [nums[i], nums[j]]
        return []
```

## Three Sum
https://www.lintcode.com/problem/3sum/description
```python
    def threeSum(self, nums):
        '''先排序，转变成了求target为-nums[i]的两个元素的和
        O(n^2) = O(nlogn) + O(n^2)
        '''
        if not nums:
            return []
        nums.sort()
        res = []
        for i in range(len(nums)):
            target = -nums[i]
            j, k = i+1, len(nums)-1
            while j<k:
                if nums[j]+nums[k]==target:
                    tmp = [nums[i], nums[j], nums[k]]
                    if tmp not in res:
                        res.append(tmp)
                    j += 1
                elif nums[j]+nums[k]<target:
                    j += 1
                else:
                    k -= 1
        return res
```
## Target Sum
https://leetcode.com/problems/target-sum/

分析：
> 首先进行数学分析，赋予标号后，集合中包含负数这正数，则有 sum(P)-sum(N) = S。因为sum(P)+sum(N)=sum(nums)，则有2*sum(P)=sum(nums)+S，故sum(P)=(sum(nums)+S)/2，由于target = (sum(nums)+S)/2是固定的整数，所以只需要找到和为它的组合数即可，题目就变成了：**从nums中（nums中的元素为非负数）找到和为target的组合的个数**。
运用dp的方法如下：
```
定义dp[10]数组, dp[10] = {1,0,0,0,0,0,0,0,0,0}

dp[i]表示子集合元素之和等于当前目标值的方案个数, 当前目标值等于9减去当前元素值

当前元素等于1时，  
                dp[9] = dp[9] + dp[9-1]

                dp[8] = dp[8] + dp[8-1]

                ...

                dp[1] = dp[1] + dp[1-1]

当前元素等于2时，
                dp[9] = dp[9] + dp[9-2]

                dp[8] = dp[8] + dp[8-2]

                ...

                dp[2] = dp[2] + dp[2-2]

当前元素等于3时
                dp[9] = dp[9] + dp[9-3]

                dp[8] = dp[8] + dp[8-3]

                ...

                dp[3] = dp[3] + dp[3-3]

当前元素等于4时，

                ...

当前元素等于5时，

                ...

                dp[5] = dp[5] + dp[5-5]

最后返回dp[-1]即是所求的解
```
```python
    def targetSum(self, nums, S):
        '''给nums中元素置 + - 号，使和为S
        转换成：从nums中挑选和为target的组合的方案数
        利用dp
        '''
        if sum(nums)<S:
            return 0
        if (S+sum(nums))%2!=0:
            return 0
        # 从nums中挑出和为target的元素，一共有多少种方案
        target = (S+sum(nums))//2
        print(target)
        dp = [0]*(target+1)
        dp[0] = 1
        for num in nums:
            for i in range(target, num-1, -1):
                dp[i] += dp[i-num]
        print(dp)
        return dp[-1]
```
- 刚开始想用
```python
for i in range(1, target+1):
    for num in nums:
        if i-num>0 and i-num<=i:
            dp[i] += dp[i-num]
```
这样不对，因为假如从[1,1,1]中凑2,dp的下标从1到2, dp[1]=3,dp[2]并不是dp[1]+dp[2-1],这样不对,应该dp[2]=3。所以把num循环放在了外边，避免重复。
- dp[0]表示，当target-num为0的时候，也就是target本身存在于num中的时候。

## 最大子序和
https://leetcode.com/problems/maximum-subarray/
```python
    def maxmumSubarray(self, nums):
        if not nums:
            return 0
        maxsum = nums[0]
        tmpsum = nums[0]
        for num in nums[1:]:
            if tmpsum<0:
                tmpsum = 0
            tmpsum += num
            maxsum = max(maxsum, tmpsum)
        return maxsum
```
## 找到出现了两次的那个数字
https://leetcode.com/problems/find-the-duplicate-number/
其余数字都只出现了1次，且一共N+1个数，数字范围在[1,N]之间

要求：
- 不能修改原数组
- 空间复杂度不超过O(1)
- 时间复杂度不超过O(n2)
- 有且只有1个重复了的数

分析:
参考：https://blog.csdn.net/wr339988/article/details/53617914
```
思路1,利用一个规律,由于数组中的数字是[1,N-1]之间的，如果是5个数，正常应该是[1 2 3 4 5]，若没有元素重复，则中间值 mid = (1+5)//2 = 3 左右两边的元素个数应该相等。

我们遍历数组，假设数组中的某一个数字x重复了，去后边的数组中找x
先把原数组看成[1 2 3 4 5]来看，如果是这样，先找中间的数mid=3.现在我们遍历数组的所有元素并统计<=3的元素个数，记作cnt好了，那么有：
假如是2重复了，那么就是[1 2 3 4 2], cnt=4, cnt>3, 则目标数字在左边
假如是4重复了，那么就是[1 2 3 4 4], cnt=3, cnt<=3,则目标数字在右边
```
```python
    def findDuplicate(self, nums):
        '''二分查找
        O(nlogn)
        '''
        N = len(nums)
        l = 1
        r = N
        while l<r:
            mid = (l+r)//2
            cnt = 0
            for num in nums:
                if num<=mid:
                    cnt += 1
            if cnt<=mid:
                l = mid+1
            else:
                r = mid
        return l
```
```
思路2，转变成环形链表中找环的入口
```
```python
    def findDuplicate(self, nums):
        slow = 0
        fast = 0
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow==fast:
                break
        # slow和fast在环中某一个处相遇
        fast = 0
        while slow!=fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
```

# 栈和队列
## Min Stack
https://leetcode.com/problems/min-stack/
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

+ push(x) -- Push element x onto stack.
+ pop() -- Removes the element on top of the stack.
+ top() -- Get the top element.
+ getMin() -- Retrieve the minimum element in the stack.

Example:
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
```
分析：easy题，第一个stack s1存原元素，第二个stack存对应元素的最小值。

Runtime: 40 ms, faster than 99.96%
```python
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.s1 = []
        self.s2 = []

    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        self.s1.append(x)
        if not self.s2:
            self.s2.append(x)
        else:
            top = self.s2[-1]
            if x<top:
                self.s2.append(x)
            else:
                self.s2.append(top)

    def pop(self):
        """
        :rtype: None
        """
        if self.s1:
            self.s1.pop()
            self.s2.pop()

    def top(self):
        """
        :rtype: int
        """
        if self.s1:
            return self.s1[-1]

    def getMin(self):
        """
        :rtype: int
        """
        if self.s2:
            return self.s2[-1]
```

## Implement Queue using Stacks
https://leetcode.com/problems/implement-queue-using-stacks/
Implement the following operations of a queue using stacks.

+ push(x) -- Push element x to the back of queue.
+ pop() -- Removes the element from in front of queue.
+ peek() -- Get the front element.
+ empty() -- Return whether the queue is empty.

Example:
```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // returns 1
queue.pop();   // returns 1
queue.empty(); // returns false
```
Notes:
```
- You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
- Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
- You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).
```
分析：用两个栈，元素入队是入s1，当出队时需要把s1中的元素都弹出到s2，然后返回s2的栈顶。peek和pop类似。

Runtime: 8 ms, faster than 99.77% 
```python
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = []
        self.s2 = []

    def push(self, x):
        """
        Push element x to the back of queue.
        :type x: int
        :rtype: None
        """
        self.s1.append(x)

    def pop(self):
        """
        Removes the element from in front of queue and returns that element.
        :rtype: int
        """
        if not self.s2 and self.s1:
            while self.s1:
                top = self.s1.pop()
                self.s2.append(top)
        return self.s2.pop()
                

    def peek(self):
        """
        Get the front element.
        :rtype: int
        """
        if not self.s2 and self.s1:
            while self.s1:
                top = self.s1.pop()
                self.s2.append(top)
        return self.s2[-1]

    def empty(self):
        """
        Returns whether the queue is empty.
        :rtype: bool
        """
        if not self.s1 and not self.s2:
            return True
        return False
```


# 0-1背包问题
0-1 背包问题：给定 $n$ 种物品和一个容量为 $C$的背包，物品 $i$ 的重量是 $w_i$，其价值为 $v_i$ 。
问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？


设$B(n,C)$表示从$n$个物品里面选物品，容量为$C$,能达到的最大价值，那么对于每个物品，都有<u>选择或者不选择</u>两种情况，所以，当没有多余的空间去放另一个物品时，$B(n,C)=B(n−1,C)$，当有多余的空间去放另一个物品时，$B(n,C)=max{B(n−1,C),B(n−1,c−w_i)+v_i}$


这里有一个误区：如果有多余空间去放置的话,那么放置肯定比不放的价值大啊，因为我多放入一个物品了啊，也就是说选择不放的函数$B(n−1,x)$肯定小于放置的函数$B(n−1,C−w)+v_i$，说到这里你就犯了一个**惯性错误**，认为$B(n−1,x)$与$B(n−1,C−w)$所对应的选择的集合$x={x_1,x_2,.....x_n}$组合相同，在理解这个函数的意义：从$n$个物品里面选物品，容量为$C$,能达到的最大价值。这个两个函数组合不一定相同，为容量$C$约束条件变了。就会变为从$n-1$个物品里面选，容量为$C$与从$n-1$个物品里面选，容量为$c-w$且加上$v$,两者哪个大。彻底理解了函数$B$之后，我相信没有什么能够阻挡你学习这个算法了。 

# 字符串
## Find Common Characters
https://leetcode.com/problems/find-common-characters/
Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.

You may return the answer in any order.

Example 1:
```
Input: ["bella","label","roller"]
Output: ["e","l","l"]
```
Example 2:
```
Input: ["cool","lock","cook"]
Output: ["c","o"]
```

Note:
```
1 <= A.length <= 100
1 <= A[i].length <= 100
A[i][j] is a lowercase letter
```
分析：
1、用两个dictionary，一个tmp用于记录A中每个字符串s中的a——z出现的次数；一个dic用于和tmp对a——>z对应次数取最小值。

Runtime: 60 ms, faster than 57.37% 
```python
    def commonChars(self, A):
        if not A:
            return []
        dic = {}
        tmp = {}
        for i in range(97, 123):
            ch = chr(i)
            dic[ch] = 0
            tmp[ch] = 0
        for idx in range(len(A)):
            for ch in tmp:
                tmp[ch] = 0
            for ch in A[idx]:
                tmp[ch] += 1 #更新的
            if idx==0:
                dic = tmp.copy()
            else:
                for i in range(97, 123):
                    ch = chr(i)
                    dic[ch] = min(dic[ch], tmp[ch])
        res = []
        for ch in dic:
            if dic[ch]>0:
                for i in range(dic[ch]):
                    res.append(ch)
        return res
```
2、利用Counter

Runtime: 72 ms, faster than 33.45% 
```python
    def commonChars(self, A):
        """
        :type A: List[str]
        :rtype: List[str]
        """
        cnt = collections.Counter(A[0])
        for s in A:
            cnt &= collections.Counter(s)
        return list(cnt.elements())
```