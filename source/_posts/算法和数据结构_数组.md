---
title: 数组
date: 2019-04-18 19:43:36
tags: 
- 算法题目分类
categories: 算法和数据结构
---
# 数组
## Two Sum
https://leetcode.com/problems/two-sum/
```python
    def twoSum_1(self, nums, target):
        '''利用哈希
        O(n)
        '''
        if not nums:
            return []
        dic = {}
        for i in range(len(nums)):
            if nums[i] not in dic:
                dic[target-nums[i]] = i
            else:
                return [dic[nums[i]], i]
    
    def twoSum_2(self, nums, target):
        '''先排序，再左右指针
        不过这种方法只能返回元素值,而不能得到下标
        O(nlogn) = O(nlogn)+O(n)
        '''
        if not nums:
            return []
        nums.sort()
        i, j = 0, len(nums)-1
        while i<j: #首尾指针，不能等于
            if nums[i]+nums[j]<target:
                i += 1
            elif nums[i]+nums[j]>target:
                j -= 1
            else:
                return [nums[i], nums[j]]
        return []
```

## 3 Sum
https://www.lintcode.com/problem/3sum/description
```python
    def threeSum(self, nums):
        '''先排序，转变成了求target为-nums[i]的两个元素的和
        O(n^2) = O(nlogn) + O(n^2)
        '''
        if not nums:
            return []
        nums.sort()
        res = []
        for i in range(len(nums)):
            target = -nums[i]
            j, k = i+1, len(nums)-1
            while j<k:
                if nums[j]+nums[k]==target:
                    tmp = [nums[i], nums[j], nums[k]]
                    if tmp not in res:
                        res.append(tmp)
                    j += 1
                elif nums[j]+nums[k]<target:
                    j += 1
                else:
                    k -= 1
        return res
```
## Target Sum
https://leetcode.com/problems/target-sum/

分析：
> 首先进行数学分析，赋予标号后，集合中包含负数这正数，则有 sum(P)-sum(N) = S。因为sum(P)+sum(N)=sum(nums)，则有2*sum(P)=sum(nums)+S，故sum(P)=(sum(nums)+S)/2，由于target = (sum(nums)+S)/2是固定的整数，所以只需要找到和为它的组合数即可，题目就变成了：**从nums中（nums中的元素为非负数）找到和为target的组合的个数**。
运用dp的方法如下：
```
定义dp[10]数组, dp[10] = {1,0,0,0,0,0,0,0,0,0}

dp[i]表示子集合元素之和等于当前目标值的方案个数, 当前目标值等于9减去当前元素值

当前元素等于1时，  
                dp[9] = dp[9] + dp[9-1]

                dp[8] = dp[8] + dp[8-1]

                ...

                dp[1] = dp[1] + dp[1-1]

当前元素等于2时，
                dp[9] = dp[9] + dp[9-2]

                dp[8] = dp[8] + dp[8-2]

                ...

                dp[2] = dp[2] + dp[2-2]

当前元素等于3时
                dp[9] = dp[9] + dp[9-3]

                dp[8] = dp[8] + dp[8-3]

                ...

                dp[3] = dp[3] + dp[3-3]

当前元素等于4时，

                ...

当前元素等于5时，

                ...

                dp[5] = dp[5] + dp[5-5]

最后返回dp[-1]即是所求的解
```
```python
    def targetSum(self, nums, S):
        '''给nums中元素置 + - 号，使和为S
        转换成：从nums中挑选和为target的组合的方案数
        利用dp
        '''
        if sum(nums)<S:
            return 0
        if (S+sum(nums))%2!=0:
            return 0
        # 从nums中挑出和为target的元素，一共有多少种方案
        target = (S+sum(nums))//2
        print(target)
        dp = [0]*(target+1)
        dp[0] = 1
        for num in nums:
            for i in range(target, num-1, -1):
                dp[i] += dp[i-num]
        print(dp)
        return dp[-1]
```
- 刚开始想用
```python
for i in range(1, target+1):
    for num in nums:
        if i-num>0 and i-num<=i:
            dp[i] += dp[i-num]
```
这样不对，因为假如从[1,1,1]中凑2,dp的下标从1到2, dp[1]=3,dp[2]并不是dp[1]+dp[2-1],这样不对,应该dp[2]=3。所以把num循环放在了外边，避免重复。
- dp[0]表示，当target-num为0的时候，也就是target本身存在于num中的时候。

# 最大子序和
https://leetcode.com/problems/maximum-subarray/
```python
    def maxmumSubarray(self, nums):
        if not nums:
            return 0
        maxsum = nums[0]
        tmpsum = nums[0]
        for num in nums[1:]:
            if tmpsum<0:
                tmpsum = 0
            tmpsum += num
            maxsum = max(maxsum, tmpsum)
        return maxsum
```
# 找到出现了两次的那个数字
https://leetcode.com/problems/find-the-duplicate-number/
其余数字都只出现了1次，且一共N+1个数，数字范围在[1,N]之间

要求：
- 不能修改原数组
- 空间复杂度不超过O(1)
- 时间复杂度不超过O(n2)
- 有且只有1个重复了的数

分析:
参考：https://blog.csdn.net/wr339988/article/details/53617914
```
思路1,利用一个规律,由于数组中的数字是[1,N-1]之间的，如果是5个数，正常应该是[1 2 3 4 5]，若没有元素重复，则中间值 mid = (1+5)//2 = 3 左右两边的元素个数应该相等。

我们遍历数组，假设数组中的某一个数字x重复了，去后边的数组中找x
先把原数组看成[1 2 3 4 5]来看，如果是这样，先找中间的数mid=3.现在我们遍历数组的所有元素并统计<=3的元素个数，记作cnt好了，那么有：
假如是2重复了，那么就是[1 2 3 4 2], cnt=4, cnt>3, 则目标数字在左边
假如是4重复了，那么就是[1 2 3 4 4], cnt=3, cnt<=3,则目标数字在右边
```
```python
    def findDuplicate(self, nums):
        '''二分查找
        O(nlogn)
        '''
        N = len(nums)
        l = 1
        r = N
        while l<r:
            mid = (l+r)//2
            cnt = 0
            for num in nums:
                if num<=mid:
                    cnt += 1
            if cnt<=mid:
                l = mid+1
            else:
                r = mid
        return l
```
```
思路2，转变成环形链表中找环的入口
```
```python
    def findDuplicate(self, nums):
        slow = 0
        fast = 0
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow==fast:
                break
        # slow和fast在环中某一个处相遇
        fast = 0
        while slow!=fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
```
