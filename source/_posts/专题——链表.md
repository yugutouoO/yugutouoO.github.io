---
title: 专题——链表
date: 2019-04-18 16:55:57
tags: 
- LinkedList
top: 10
categories: Algorithm
---
# 在O(1)时间复杂度删除链表节点
https://leetcode.com/problems/delete-node-in-a-linked-list/
题目描述：给定一个单链表中的表头和一个等待被删除的节点(非表头或表尾)。请在在O(1)时间复杂度删除该链表节点。并在删除该节点后，返回表头。

样例：给定 1->2->3->4，和节点 3，返回 1->2->4。

分析：题目中给定了要删除的节点node，只需要获得node.next这个节点，然后把node的val和next更新为它的next对应的值。即
```
node.val = node.next.val
node.next = node.next.next
```
注意：这种方法只适用于不是头结点或尾结点的情况，如果不是这两种情况，还是需要用传统方法从头往后遍历。不过呢，这种方法的平均时间复杂度还是O(1),(O(1)*n+O(n))/n = O(1) haha

```python
    def deleteNode(self, node):
        '''删除链表中的节点（不含尾结点）
        '''
        node.val = node.next.val
        node.next = node.next.next
```

# 反转链表
https://leetcode.com/problems/reverse-linked-list/
无环哦
```python
    def reverseList(self, head):
        '''反转链表
        '''
        if not head:
            return None
        pre = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```
# 判断链表是否有环
```python
    def hasCycle(self, head):
        '''判断链表是否有环
        '''
        if not head or not head.next:
            return False
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        if not fast or not fast.next:
            return False
        else:
            return True
```

# 环形链表的入口节点
https://leetcode.com/problems/linked-list-cycle-ii/

```python
class Solution(object):
    def detectCycle(self, head):
        """
        环形链表的入口节点
        :type head: ListNode
        :rtype: ListNode
        """
        def hasCircle(head):
            if not head or not head.next:
                return None
            slow = head
            fast = head
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
                if slow==fast:
                    break
            if not fast or not fast.next:
                return None
            else:
                return fast
        meetNode = hasCircle(head)
        if not meetNode:
            return None
        cur = head
        while cur!=meetNode:
            cur = cur.next
            meetNode = meetNode.next
        return cur
```
# 两个链表的公共节点
https://leetcode.com/problems/intersection-of-two-linked-lists/
```python
    def getIntersectionNode(self, headA, headB):
        '''两个链表的公共节点
        '''
        if not headA or not headB:
            return None
        curA = headA
        curB = headB
        while curA!=curB:
            curA = curA.next if curA else headB
            curB = curB.next if curB else headA
        return curA
```

# 链表的中间节点
https://leetcode.com/problems/middle-of-the-linked-list/
```python
    def middleNode(self, head):
        '''链表的中间节点 利用快慢指针
        0->1->2->3    返回2
        0->1->2->3->4 返回2
        '''
        if not head:
            return None
        if not head.next:
            return head
        slow = head
        fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
```

# 判断回文链表
https://leetcode.com/problems/palindrome-linked-list/

```python
    def isPalindrome(self, head):
        '''判断回文链表  
        找到中间节点的过程中反转左半部分的链表
        然后比较左右
        '''
        if not head or not head.next:
            return True
        pre, slow, fast = None, head, head
        while fast and fast.next:
            fast = fast.next.next
            nxt = slow.next
            slow.next = pre
            pre = slow
            slow = nxt
        # 最后，slow仍是中间节点2，它的next指向还没来得及变
        # 所以pre是前一个节点，如果是奇数个节点，slow需要后移到3
        if fast:                # 这里不写成if not fast.next的原因是：如果偶数个节点时fast为None
            slow = slow.next
        while slow and pre:
            if slow.val!=pre.val:
                return False
            slow = slow.next
            pre = pre.next
        return True
```

# 合并两个有序链表
https://leetcode.com/problems/merge-two-sorted-lists/

非递归
```python
    def mergeTwoLists(self, l1, l2):
        dummy = cur = ListNode(-1)
        while l1 and l2:
            if l1.val<=l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        cur.next = l1 or l2
        return dummy.next
```

递归
```python
    def mergeTwoLists(self, l1, l2):
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val<l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```



