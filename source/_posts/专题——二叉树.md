---
title: 二叉树
date: 2019-04-14 22:18:37
tags: 
- 算法题目分类
categories: 算法和数据结构
---
# 二叉树的生成和遍历
```python
# 待修改为python
```
## 二叉树的结点类
```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {
        val = x;
    }
}
```
## 生成一棵二叉树
```java
public static void createBinaryTree(int[] arr, List<TreeNode> list){
    // 1.将数组中的数字都变成TreeNode节点，存到list中
    for (int i = 0; i < arr.length; i++) {
        list.add(new TreeNode(arr[i]));
    }

    // 2.编号为n的节点，他的左子节点编号为2*n+1，右子节点编号为2*n+2
    //   最后一个父节点有可能没有右子节点，需要单独处理
    for (int i = 0; i < arr.length/2-1; i++) {
        list.get(i).left = list.get(i*2+1);
        list.get(i).right = list.get(i*2+2);
    }

    // 3.单独处理最后一个父节点  因为它有可能没有右子节点
    //   如果有奇数个节点，最后一个父节点才有右子节点
    int index = arr.length/2-1;
    list.get(index).left = list.get(index*2+1);
    if(arr.length%2!=0)list.get(index).right = list.get(index*2+2);
}
```
## 先序、中序、后序递归遍历二叉树
```java
// 先序递归
public void preTra(Node node){
    if(node==null)return;
    preTra(node.leftChild);
    preTra(node.rightChild);
}
// 中序递归
public void inTra(Node node){
    if(node==null)return;
    inTra(node.leftChild);
    System.out.print(node.data+" ");
    inTra(node.rightChild);
}
// 后序递归
public void postTra(Node node){
    if(node==null)return;
    postTra(node.leftChild);
    postTra(node.rightChild);
    System.out.print(node.data+" ");
}
```
## 先序非递归遍历二叉树（利用栈）
```java
public void preOrder(TreeNode node){//用栈
    Stack<TreeNode> stack = new Stack<>();
    if(node==null)return;
    stack.push(node);
    while (!stack.empty()){
        TreeNode top = stack.pop();
        System.out.println(top.val);
        if(top.right!=null)stack.push(top.right);
        if(top.left!=null)stack.push(top.left);
    }
}
```
## 中序非递归遍历二叉树（利用栈）
***边界的考虑很巧妙** 直接利用stack和root是否均为空判断结束，并且一直只用root
```python
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        stack = []
        res = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop()
                res.append(root.val)
                root = root.right
        return res
```
## 后序非递归遍历二叉树（1.利用双栈）
![](/images/postorder.png)
```java
public void postOrder1(TreeNode node){
    if(node==null)return;
    Stack<TreeNode> stack1 = new Stack<>();
    Stack<TreeNode> stack2 = new Stack<>();
    stack1.push(node);
    while (!stack1.empty()){
        node = stack1.pop();
        stack2.push(node);
        if(node.left!=null)stack1.push(node.left);
        if(node.right!=null)stack1.push(node.right);
    }
    while (!stack2.empty()){
        System.out.println(stack2.pop().val);
    }
}
```
## 后序非递归遍历二叉树（2.利用先序遍历）
```java
// 后序非递归2，利用从右往左的先序遍历，最后反转
public void postOrder3(TreeNode node){
    if(node==null)return;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(node);
    List<Integer> list = new LinkedList<>();
    while (!stack.empty()){
        node = stack.pop();
        list.add(node.val);
        if(node.left!=null)stack.push(node.left);
        if(node.right!=null)stack.push(node.right);
    }
    Collections.reverse(list);
    for(int x:list)
        System.out.println(x);
}
```
## 二叉树的层次遍历（利用队列）
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        queue = []
        res = []
        out_size = 1
        in_size = 0
        queue.append(root)
        while queue:
            tmp = []
            while out_size:
                top = queue.pop(0)
                tmp.append(top.val)
                out_size -= 1
                if top.left:
                    queue.append(top.left)
                    in_size += 1
                if top.right:
                    queue.append(top.right)
                    in_size += 1
            res.append(tmp)
            out_size = in_size
            in_size = 0
        return res
```
## 二叉树的层次遍历——>进阶版：分层输出（利用队列）
```python
class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    def levelOrder(self, root):
        if not root:
            return []
        queue = []
        queue.append(root)
        out_cnt = 1
        in_cnt = 0
        res = []
        while queue:
            tmp = []
            while out_cnt > 0:
                out = queue[0]
                queue.pop(0)
                out_cnt -= 1
                tmp.append(out.val)
                if out.left:
                    queue.append(out.left)
                    in_cnt += 1
                if out.right:
                    queue.append(out.right)
                    in_cnt += 1
            out_cnt = in_cnt
            in_cnt = 0
            res.append(tmp)
        return res
```
#  二叉树的层次遍历——>进阶版：分层Z型输出（利用队列）
分析：和上边相比只是多了个flag
```python
        if not root:
            return []
        queue = []
        queue.append(root)
        out_cnt = 1
        in_cnt = 0
        res = []
        flag = True # True，从左往右，False，从右往左
        while queue:
            tmp = []
            while out_cnt > 0:
                out = queue[0]
                queue.pop(0)
                tmp.append(out.val)
                if out.left:
                    queue.append(out.left)
                    in_cnt += 1
                if out.right:
                    queue.append(out.right)
                    in_cnt += 1
                out_cnt -= 1
            out_cnt = in_cnt
            in_cnt = 0
            if flag:
                res.append(tmp)
            else:
                res.append(tmp[::-1])
            flag = not flag
        return res
```

# 二叉树的深度
https://leetcode.com/problems/maximum-depth-of-binary-tree/
分析：
```
终止条件：not root
终止返回值：看我需要什么

递归体：对于root这个节点来说，它的深度是：1+*左右子树中最大的深度*

```
```python
    def maxDepth(self, root):
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

# 两个任意节点间的最大距离
https://leetcode.com/problems/diameter-of-binary-tree/
分析：肯定是某个节点的左右子树深度之和
思路1，，一个时间复杂度很高的递归
```python
    def diameterOfBinaryTree(self, root):
        if not root:
            return 0
        L = self.getDepth(root.left)
        R = self.getDepth(root.right)
        return max(L+R, self.diameterOfBinaryTree(root.left), self.diameterOfBinaryTree(root.right))
    
    def getDepth(self, root):
        if not root:
            return 0
        return 1 + max(self.getDepth(root.left), self.getDepth(root.right))
```

思路2，优化，不需要调用两次递归，在计算深度的时候就顺便更新了~
```python
class Solution(object):
    def __init__(self):
        self.ans = 0
    def diameterOfBinaryTree(self, root):
        self.getDepth(root)
        return self.ans
        pass
    def getDepth(self, root):
        if not root:
            return 0
        L = self.getDepth(root.left)
        R = self.getDepth(root.right)
        self.ans = max(self.ans, L+R)
        return 1 + max(L, R)
```

# 两个节点的最近公共祖先节点
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
分析：对每个节点，在左右子树搜索p和q节点
```
    root
    /   \
left    right

root.left表示，root的左子树的根节点
left = self.lowestCommonAncestor(root.left, p, q)表示，在root的左子树中搜索p、q节点，如果搜到了，left就是这个左子树的根节点。

需要明确，如果在左子树搜到了，那么left是搜到的p或q节点的父节点。

而如果两个都搜到了，root是公共祖先。
```

```python
    def lowestCommonAncestor(self, root, p, q):
        '''最低公共祖先节点
        '''
        if root==p or root==q:
            return root
        left = right = None
        if root.left:
            left = self.lowestCommonAncestor(root.left, p, q) 
            
        if root.right:
            right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        return left if left else right
```

# 二叉树的镜像
https://leetcode.com/problems/symmetric-tree/
```python
    def isSymmetric(self, root):
        return self.isSym(root, root)

    def isSym(self, rootA, rootB):
        if not rootA and not rootB:
            return True
        if not rootA or not rootB:
            return False
        if rootA.val!=rootB.val:
            return False
        return self.isSym(rootA.left, rootB.right) and self.isSym(rootA.right, rootB.left)
```
# 合并两棵二叉树
https://leetcode.com/problems/merge-two-binary-trees/

```python
    def mergeTrees(self, t1, t2):
        if not t1 and not t2:
            return None
        if not t1:
            return t2
        if not t2:
            return t1
        root = TreeNode(t1.val + t2.val)
        root.left = self.mergeTrees(t1.left, t2.left)
        root.right = self.mergeTrees(t1.right, t2.right)
        return root  
```
# 翻转二叉树
https://leetcode.com/problems/invert-binary-tree/
```python
    def invertTree(self, root):
        def recursive(A):
            if not A:
                return None
            root = TreeNode(A.val)
            root.left = recursive(A.right)
            root.right = recursive(A.left)
            return root
        return recursive(root)
```

# 判断平衡二叉树
LeetCode 110. Balanced Binary Tree
https://leetcode.com/problems/balanced-binary-tree/submissions/

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example 1:
```
Given the following tree [3,9,20,null,null,15,7]:

    3
   / \
  9  20
    /  \
   15   7
Return true.
```
Example 2:
```
Given the following tree [1,2,2,3,3,null,null,4,4]:

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
```
分析：判断一个树是不是平衡二叉树，就是判断是不是每个节点的左右子树的高度之差的绝对值小于等于1
求高度已经会用递归求了，接下来就是对每个节点递归求左右子树的高度，加个判断。

```python
    def getDepth(self, root):
        if not root:
            return 0
        return 1+max(self.getDepth(root.left), self.getDepth(root.right))

    def isBalanced(self, root):
        if not root:
            return True
        leftHeight = self.getDepth(root.left)
        rightHeight = self.getDepth(root.right)
        if abs(leftHeight-rightHeight)>1:
            return False
        else:
            return self.isBalanced(root.left) and self.isBalanced(root.right) 
```


Runtime: 32 ms, faster than 99.77% 
# 判断两个树是否相同
https://leetcode.com/problems/same-tree/
Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Example 1:
```
Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
```
Example 2:
```
Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
```
Example 3:
```
Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
```
分析：递归检查即可。直到最后两个树都为空时才return True，否则一直递归比较两个树的左右节点。

Runtime: 12 ms, faster than 46.6%
```python
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        if not p and not q:
            return True
        if not p or not q:
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
分析优化：整棵树有很多冗余无意义的遍历，其实我们在处理完getDepth这个高度的时候，我们完全可以在检查每个节点高度并且返回的同时，记录左右差是否已经超过1，只要有一个节点超过1，那么直接返回False即可，因此我们只需要在外围设立一个全局变量记录True和False，在调用getDepth的时候，内置代码里加入对左右高度的判定即可

优化之后
Runtime: 12 ms, faster than 99.93%
```python
    def __init__(self):
        self.is_balance = True
        
    def getDepth(self, root):
        if not root:
            return 0
        left = self.getDepth(root.left)
        right = self.getDepth(root.right)
        if abs(left-right) > 1:
            self.is_balance = False
        
        return max(left, right)+1

    def isBalanced(self, root):
        if not root:
            return True
        self.getDepth(root)
        return self.is_balance
```


# convertBST
https://leetcode.com/problems/convert-bst-to-greater-tree/
```python
    def __init__(self):
        self.sum = 0

    def convertBST(self, root):
        '''利用中序遍历的逆序，这样可以累加
        '''
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return None
        self.convertBST(root.right)
        tmp = root.val
        root.val += self.sum
        self.sum += tmp
        self.convertBST(root.left)
        return root
```

# Path Sum 
https://leetcode.com/problems/path-sum/
```python
    def hasPathSum(self, root, target):
        '''是否存在 root-to-leaf
        '''
        def dfs(root, target):
            if not root:
                return False
            if not root.left and not root.right and root.val==target:
                return True
            return dfs(root.left, target-root.val) or dfs(root.right, target-root.val)
        return dfs(root, target)
```
# Path Sum
https://leetcode.com/problems/path-sum-ii/

**Path Sum II. root-to-leaf**

之前错在了：先`path.append(root.val)`，然后对左右子树进行dfs，最后再`path.pop()`，这样不对，因为从左子树出来进右子树时也要还原
所以最好把path的更新写在对左右子树的dfs里

```python
    def pathSum(self, root, target):
        ''' root-to-leaf 节点记录到res列表中
        '''
        res = []
        def dfs(root, res, path, target):
            if not root:
                return
            if not root.left and not root.right and target == root.val: # 前边两个判断保证是叶子节点 
                res.append(path+[root.val])
            dfs(root.left, res, path+[root.val], target-root.val)
            dfs(root.right, res, path+[root.val], target-root.val)
        dfs(root, res, [], target)
        return res
```
# Path Sum III
https://leetcode.com/problems/path-sum-iii/
```python
    def pathSum(self, root, target):
        ''' 不必从root开始或从leaf结束，但一定要从上边节点到下边节点
        The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
        '''
        if not root:
            return 0
        def dfs(root, target):
            res = 0
            if not root:
                return 0
            if target == root.val:  # PathSum不要求是叶子节点
                res += 1
            res += dfs(root.left, target-root.val)
            res += dfs(root.right, target-root.val)
            return res
        result = dfs(root, target) \
            + self.pathSum(root.left, target) \
            + self.pathSum(root.right, target)
        return result
```
# Sum of Root To Leaf Binary Numbers 
https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/

Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.

Return the sum of these numbers.

 

Example 1:
![](/images/lc1022.png)
```
Input: [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
``` 
Note:
```
The number of nodes in the tree is between 1 and 1000.
node.val is 0 or 1.
The answer will not exceed 2^31 - 1.
```
分析：dfs得到所有root-to-leaf的路径，然后转换。
但其实你可以在dfs过程中进行转换，不再用path存路径，而是用整数tmp，每次tmp*2加上新值

beats 100%
```python
    def sumRootToLeaf(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        res = []
        def dfs(root, res, tmp):
            if not root:
                return
            if not root.left and not root.right:
                res.append(tmp*2+root.val)
                return
            dfs(root.left, res, tmp*2+root.val)
            dfs(root.right, res, tmp*2+root.val)
        dfs(root, res, 0)
        return sum(res)
```


# Convert Sorted Array to Binary Search Tree
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:
```
Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```
分析：肯定是用到递归，设计一个函数：根据nums数组中间的元素返回一个根节点。对于原数组产生的根节点root，root.left是对左半部分数组产生根节点，root.right是对右半部分数组产生根节点，对每个节点都做同样的操作。

beats 60%
```python
    def sortedArrayToBST(self, nums):
        if not nums:
            return None
        root = self.roots(nums)
        idx = nums.index(root.val)
        root.left = self.sortedArrayToBST(nums[:idx])
        root.right = self.sortedArrayToBST(nums[idx+1:])
        return root

    def roots(self, nums):
        if not nums:
            return None
        return TreeNode(nums[(len(nums)-1)//2])
```

# Minimum Absolute Difference in BST
https://leetcode.com/problems/minimum-absolute-difference-in-bst/submissions/

Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.

Example:

```
Input:

   1
    \
     3
    /
   2

Output:
1

Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).
```

分析：题目是BST中任意两个节点中差的绝对值最小的。利用BST的性质，进行中序遍历，每次把root的前一数字存起来，并更新dif。

Runtime: 36 ms, faster than 100.00% 

```python
    def __init__(self):
        self.dif = 10000
        self.preNumber = -10000

    def getMinimumDifference(self, root):
        return self.inTraverse(root)
        
    # inorder traverse and update dif and preNumber
    def inTraverse(self, root):
        if not root:
            return
        self.inTraverse(root.left)
        self.dif = min(self.dif, root.val-self.preNumber)
        self.preNumber = root.val
        self.inTraverse(root.right)
        return self.dif
```
# 左叶子节点的和
https://leetcode.com/problems/sum-of-left-leaves/
Find the sum of all left leaves in a given binary tree.

Example:
```
    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
```

分析：先序遍历（其它的遍历方式也可以），判断如果是左叶子节点则加到self.sum中去
Runtime: 24 ms, faster than 76.49%
```python
    def __init__(self):
        self.sum_lc404  = 0
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def preTraverse(root):
            if not root:
                return
            if root.left:
                if not root.left.left and not root.left.right:
                    self.sum_lc404 += root.left.val
                preTraverse(root.left)
            preTraverse(root.right)
        preTraverse(root)
        return self.sum_lc404
```
# 打印所有的root-to-leaf的路径
https://leetcode.com/problems/binary-tree-paths/
Given a binary tree, return all root-to-leaf paths.

Note: A leaf is a node with no children.

Example:
```
Input:

   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]

Explanation: All root-to-leaf paths are: 1->2->5, 1->3
```

分析：用dfs，注意打印的格式需要加个判断

Runtime: 24 ms, faster than 81.06%
```python
    def binaryTreePaths(self, root):
        res = []
        def dfs(root, res, s):
            if not root:
                return
            if s != '':
                s = s+'->'+str(root.val)
            else:
                s = s+str(root.val)
            if not root.left and not root.right:#如果是叶子节点
                res.append(s)
                return
            dfs(root.left, res, s)
            dfs(root.right, res, s)
        dfs(root, res, '')
        return res
```
# Binary Tree Tilt
https://leetcode.com/problems/binary-tree-tilt/submissions/

Given a binary tree, return the tilt of the whole tree.

The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.

The tilt of the whole tree is defined as the sum of all nodes' tilt.

Example:
```
Input: 
         1
       /   \
      2     3
Output: 1
Explanation: 
Tilt of node 2 : 0
Tilt of node 3 : 0
Tilt of node 1 : |2-3| = 1
Tilt of binary tree : 0 + 0 + 1 = 1
```
Note:

The sum of node values in any subtree won't exceed the range of 32-bit integer.
All the tilt values won't exceed the range of 32-bit integer.

分析：题目大意，每个节点的tilt是它的左右子树的差的绝对值，求所有节点的tilt之和。
一个思维上的trick就是，利用后序遍历，自底向上计算左右子树和根的值。

Runtime: 44 ms, faster than 100.00% 

```python
    def __init__(self):
        self.result_lc563 = 0
    def findTilt(self, root):
        def postTraverse(root):
            if not root:
                return 0
            left = postTraverse(root.left)
            right = postTraverse(root.right)
            self.result_lc563 += abs(right-left)
            return left+right+root.val
        postTraverse(root)
        return self.result_lc563
```
# 找到二叉树出现次数最多的节点

Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.
 

For example:
Given BST [1,null,2,2],
```
   1
    \
     2
    /
   2
 
```
return [2].

Note: If a tree has more than one mode, you can return them in any order.

Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).

分析：要找到BST中出现次数最多的节点，直观思路就是先确定最大的次数maxcnt，再把出现次数为cnt的节点加到res中。
一、先中序遍历确定最大次数maxcnt，并且存到dic中，更进一步存到counter里；再获取counter中次数为maxcnt的key添加到res
二、中序遍历过程中记录tempCnt，并实时更新maxCnt，并记录前一个节点的值。当不相等的时候，判断tempCnt和maxCnt的关系，如果tempCnt>maxCnt，就要移除res列表中添加了的元素，添加次数最多的这个；如果tempCnt==maxCnt，就直接把元素加到res中。如果小于则不添加，直接修改相应的值就好了。

参考：
https://blog.csdn.net/fuxuemingzhu/article/details/71124600
https://www.liuchuo.net/archives/3174

Runtime: 44 ms, faster than 99.18% 
```python
from collections import Counter
class Solution(object):
    def findMode(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        res = []
        self.dic = {}
        def inTraverse(root):
            if not root:
                return
            inTraverse(root.left)
            if root.val in self.dic:
                self.dic[root.val] += 1
            else:
                self.dic[root.val] = 1
            inTraverse(root.right)
        inTraverse(root)
        counter = Counter(self.dic)
        maxcnt = max(counter.values())
        for i, c in counter.items():
            if c==maxcnt:
                res.append(i)
        return res
```
不使用额外的空间，修改之后
Runtime: 40 ms, faster than 100.00%
```python
    def findMode(self, root):
        if not root:
            return []
        self.maxcnt = 0
        self.tmpcnt = 0
        self.res = []
        self.preval = root.val

        def inTraverse(root):
            if not root:
                return
            inTraverse(root.left)
            self.tmpcnt += 1
            if root.val!=self.preval:# 不等于了
                self.preval = root.val
                self.tmpcnt = 1
            if self.tmpcnt>self.maxcnt:
                self.maxcnt = self.tmpcnt
                self.res = []
                self.res.append(self.preval)
            elif self.tmpcnt == self.maxcnt:
                self.res.append(self.preval)
            inTraverse(root.right)

        inTraverse(root)
        return self.res
```




















