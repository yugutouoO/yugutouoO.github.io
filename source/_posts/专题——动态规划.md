---
title: 专题——动态规划
date: 2019-04-17 19:51:48
tags: 
- dp
top: 10
categories: Algorithm
---
# 64. Minimum Path Sum
原题：https://leetcode.com/problems/minimum-path-sum/
Given a `m x n` grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:
```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```
分析：dp，到达matrix[i][j]只能从它上边或者下边过来，用`dp[i][j]`表示到达`matrix[i][j]`的最小路径和。
- 初始，第0行和第0列的`dp`值为依次累加和
- 状态转移方程为：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]`

Runtime: 84 ms, faster than 37.22% 
```python
    def minSumPath(self, matrix):
        if not matrix:
            return 0
        M = len(matrix)
        N = len(matrix[0])
        dp = [[0 for j in range(N)] for i in range(M)]
        dp[0][0] = matrix[0][0]
        # 初始化
        for j in range(1, N):
            dp[0][j] = dp[0][j-1] + matrix[0][j]
        for i in range(1, M):
            dp[i][0] = dp[i-1][0] + matrix[i][0]
        # dp更新，只能从上边或下边到达
        for i in range(1, M):
            for j in range(1, N):
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]
        return dp[-1][-1]
```
# 931. Minimum Falling Path Sum
原题：https://leetcode.com/problems/minimum-falling-path-sum/
Given a square array of integers A, we want the minimum sum of a falling path through A.

A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.

Example 1:
```
Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: 12
Explanation: 
The possible falling paths are:
[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
```
分析：下一行的元素所在列和它前一行的元素所在列最多相差1.
到达元素`A[i][j]`的最小路径和应该从`A[i - 1][j - 1]`，`A[i - 1][j]` ，`A[i - 1][j + 1]`三者之间选。如：
```
[1, 2, 3]
[4, 5, 6] => [5, 6, 8]
[7, 8, 9] => [7, 8, 9] => [12, 13, 15]
```
Runtime: 124 ms, faster than 32.91%
```python
    def minFallingPathSum(self, A):
        N = len(A)
        dp = [[0 for i in range(N)] for j in range(N)]
        for j in range(N):
            dp[0][j] = A[0][j]
        for i in range(1, N):
            for j in range(0, N):
                dp[i][j] = min(dp[i-1][max(j-1, 0)], dp[i-1][j],
                               dp[i-1][min(j+1, N-1)]) + A[i][j]
        return min(dp[-1]) 
```
# 983. Minimum Cost For Tickets
原题：https://leetcode.com/problems/minimum-cost-for-tickets/
In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.

Train tickets are sold in 3 different ways:

a 1-day pass is sold for costs[0] dollars;
a 7-day pass is sold for costs[1] dollars;
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.

Return the minimum number of dollars you need to travel every day in the given list of days.

Example 1:
```
Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: 
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total you spent $11 and covered all the days of your travel.
```
Example 2:
```
Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation: 
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total you spent $17 and covered all the days of your travel.
```
Note:
```
1 <= days.length <= 365
1 <= days[i] <= 365
days is in strictly increasing order.
costs.length == 3
1 <= costs[i] <= 1000
```
分析：`dp[i]`表示到天数`i`所需的花费，如果第`i`天不需旅行，则它就等于`dp[i-1]`
状态转移方程：`dp[i] = min(dp[i-j]+cost[j])`，j可能是1天，7天，30天，`cost[j]`是旅行`j`天的花费

Runtime: 36 ms, faster than 46.86% 
```python
    def mincostTickets(self, days, costs):
        if not days or not costs:
            return 0
        N = len(days)
        print(N)
        dp = [0] * (days[-1]+1)
        for i in range(days[-1]+1):
            if i not in days:
                dp[i] = dp[i-1]
            else:
                dp[i] = min(dp[max(i-1, 0)]+costs[0],
                          dp[max(i-7, 0)]+costs[1], 
                          dp[max(i-30, 0)]+costs[2])
        return dp[-1]
```

# 413. Arithmetic Slices
原题：https://leetcode.com/problems/arithmetic-slices/
A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequence:
```
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
```
The following sequence is not arithmetic.
```
1, 1, 2, 5, 7
```
A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.

A slice (P, Q) of array A is called arithmetic if the sequence:
A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.

The function should return the number of arithmetic slices in the array A.


Example:
```
A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
```
分析：找到A中是Arithmetic sequence的切片。
cuur是每次的累积次数，cnt是总次数
如`1 2 3 4 5`包含`1 2 3`,`2,3,4`,`3,4,5`,`1,2,3,4`,`2,3,4,5`,`1,2,3,4,5`共5种

Runtime: 28 ms, faster than 42.93%
```python
    def numberOfArithmeticSlices(self, A):
        curr = 0
        cnt = 0
        N = len(A)
        for i in range(2, N):
            if A[i]-A[i-1] == A[i-1]-A[i-2]:
                curr += 1
                cnt += curr
            else:
                curr = 0
        return cnt
```
# 322. Coin Change
原题：https://leetcode.com/problems/coin-change/
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
```
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
```
Example 2:
```
Input: coins = [2], amount = 3
Output: -1
```
Note:
You may assume that you have an infinite number of each kind of coin.

分析：`dp[i]`表示凑出总和为i需要的硬币数，凑出总和i可以从已有coins中选
- 初始将dp值设为`aim+1`是为了更新`dp[i]`，最后需要判断dp[i]有没有凑出来，如果没有凑出来应该还是默认值`aim+1`，这时候要返回`-1`
- 状态转移方程：`dp[i]=1+min(dp[i-coin])`

Runtime: 1680 ms, faster than 14.80% 
```python
    def coinChange(self, arr, aim):
        if not arr:
            return -1
        if not aim:
            return 0
        N = len(arr)
        dp = [aim+1] * (aim+1)
        for i in range(1, aim+1):
            for coin in arr:
                if i==coin:
                    dp[i] = 1
                else:
                    dp[i] = min(dp[i], dp[max(i-coin, 0)]+1)
        return dp[-1] if dp[-1]!=(aim+1) else -1
```

# 300. 最长递增子序列
原题：https://leetcode.com/problems/longest-increasing-subsequence/
Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:
```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```
Note:
There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
Follow up: Could you improve it to O(n log n) time complexity?

分析：最长递增子序列（中元素的个数）
思路1，设dp数组，每一次遍历到x，从后往前找 $dp[i]=max\{dp[j]+1(0<=j<i，arr[j]<arr[i])\}。$ dp[j]中数值最大的那个+1。

时间复杂度：O(n^2)
Runtime: 1084 ms, faster than 11.25%
```python
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        N = len(nums)
        dp = [1]*(N)
        for i in range(1, N):
            for j in range(i, -1, -1):
                if nums[i]>nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        # print(dp)
        return max(dp)
```

思路2：利用二分查找优化时间
**用一个数组ends保存最长递增序列为k的最小元素**，如
```
nums        2 1 5 3 6 4 8 9 7
dp          1 1 2 2 3 3 4 5 4

endsindex 0 1 2 3 4 5 6 7 8 9         
ends        1 3 4 7 9
```
>ends下标为k，表示原数组中最长递增序列长度为k的这些序列中，最小的元素是ends[k]。下标从1开始是为了方便。

初始，dp[0] = 1，ends[1] = nums[0]，right = 1（有效下标边界），当遍历nums中的数x时，在ends数组中利用二分查找第一个大于等于x的数（所在ends的下标l），**（如果ends中存在这样一个数，返回所在ends下标；如果不存在，则在right右边。不过最后的下标都是l）**

**找到l下标之后，更新ends[l]=x，更新dp[i]=l（l是ends下标即最长长度），更新right为max(l, right)**

时间复杂度O(nlogn)
Runtime: 32 ms, faster than 80.94%
```python
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        N = len(nums)
        dp = [0] * N
        ends = [0] * (N+1)
        right = 1
        dp[0] = 1
        ends[1] = nums[0]
        for i in range(1, N):# nums中的数字nums[i]
            #在ends里进行二分查找
            l, r = 1, right
            while l<=r:
                mid = (l+r)//2
                if ends[mid]<nums[i]:
                    l = mid+1
                else:
                    r = mid-1
            # l是那个位置
            ends[l] = nums[i] #更新ends[l]
            dp[i] = l #更新dp
            right = max(l, right) #更新right
        return max(dp)
```
# 最长公共子串问题

给定两个字符串 str1 和 str2，返回两个字符串的最长公共子串。
Example
```
str1="1AB2345CD"，str2="12345EF"，返回"2345"。
```
要求
如果 str1 长度为 M，str2 长度为 N，实现时间复杂度为 O(MN)，额外空间复杂度为 O(1)的方法。

分析：
思路1，。`dp[i][j]` 的含义是，在必须把 s`tr1[i]`和 `str2[j]`当作公共子串最后一个字符的情况下，公共子串最长有多长。
- 初始，以str1[0]结尾和以str2[j]结尾的dp值，就是str1中第0个字符是否在str2中出现，str2同理
- 状态转移方程：`dp[i][j]`的值只可能有两种情况。 
  - 如果 `str1[i]!=str2[j]`，说明在必须把 `str1[i]`和 `str2[j]`当作公共子串最后一个字符是不 可能的，令 `dp[i][j]`=0。
  - 如果 `str1[i]==str2[j]`，说明 `str1[i]`和 `str2[j]`可以作为公共子串的最后一个字符，从 最 后 一 个 字 符 向 左 能 扩 多 大 的 长 度 呢 ？ 就 是 `dp[i-1][j-1]` 的 值 ， 所 以 令 `dp[i][j]=dp[i-1][j-1]+1`
```python
    def longestCommonStr(self, s1, s2):
        '''
        时间复杂度 O(MN)
        空间复杂度 O(MN)
        '''
        if not s1 or not s2:
            return ''
        M = len(s1)
        N = len(s2)
        dp = [[0 for j in range(N)] for i in range(M)]
        for i in range(M):
            if s1[i] == s2[0]:
                dp[i][0] = 1
        for j in range(N):
            if s1[0] == s2[j]:
                dp[0][j] = 1
        endidx = 0
        maxlen = 0
        for i in range(1, M):
            for j in range(1, N):
                if s1[i]==s2[j]:
                    dp[i][j] = dp[i-1][j-1]+1
                    if dp[i][j]>maxlen:
                        maxlen = dp[i][j]
                        endidx = i
                else:
                    dp[i][j] = 0
        return s1[endidx+1-maxlen:endidx+1]
```

思路2，优化空间复杂度
![](/images/longestcommansequence.png)
row：行起始
col：列起始
i，j是在起始行为row和起始列为col的斜线的遍历

```python
    def longestCommonStr(self, s1, s2):
        '''
        时间复杂度 O(MN)
        空间复杂度 O(1)
        '''
        if not s1 or not s2:
            return ''
        M = len(s1)
        N = len(s2)
        # 全局
        maxlen = 0
        endidx = 0
        # 控制每个斜线的行和列的开始
        row = 0
        col = N-1
        
        while row<M: # 每次斜线开始
            i = row
            j = col
            tmplen = 0
            while i<M and j<N:
                if s1[i]!=s2[j]:
                    tmplen = 0
                else:
                    tmplen += 1
                if tmplen>maxlen:
                    maxlen = tmplen
                    endidx = i
                i += 1
                j += 1
            if col>0:
                col -= 1
            else:
                row += 1
        return s1[endidx+1-maxlen:endidx+1]
```
# 最长公共子序列问题
原题：https://www.lintcode.com/problem/longest-common-subsequence/description

Description
中文
English
Given two strings, find the longest common subsequence (LCS).

Your code should return the length of LCS.

Have you met this question in a real interview?  
Clarification
What's the definition of Longest Common Subsequence?

https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
http://baike.baidu.com/view/2020307.htm
Example
Example 1:
```
	Input:  "ABCD" and "EDCA"
	Output:  1
	
	Explanation:
	LCS is 'A' or  'D' or 'C'
```

Example 2:
```
	Input: "ABCD" and "EACB"
	Output:  2
	
	Explanation: 
	LCS is "AC"
```
最长公共子序列（LCS）是一个在一个序列集合中（通常为两个序列）用来查找所有序列中最长子序列的问题。这与查找最长公共子串的问题不同的地方是：子序列不需要在原序列中占用连续的位置。而最长公共子串（要求连续）和最长公共子序列是不同的。

分析：同样设置`dp[i][j]`表示字符串s1以字符s1[i]和字符串s2以字符s2[j]结尾得到的公共子序列
- 初始，第0行，如果s1[0]和s2[j]字符相等，则置为1；如果不等的话，若前边字符是相等的，也要置为1，如下所示，若`b`和`db`的公共子序列长度为1，则`b`和`dbe`的公共子序列长度也为1.Note：不要累加，`ee`和`e`的公共子序列长度是1
```
  d b e d
b 0 1 1 1
e 0
d 1
```
- 更新dp
`dp[i][j]`的值只可能来自以下三种情况:
    - 上边
    - 下边
    - 如果s1[i]==s2[j]还可能来自左上角，`dp[i-1][j-1] + 1`
这三种情况取最大值

Total runtime 101 ms
Your submission beats 99.80% Submissions!

```python
class Solution:
    """
    @param A: A string
    @param B: A string
    @return: The length of longest common subsequence of A and B
    """
    def longestCommonSubsequence(self, s1, s2):
        if not s1 or not s2:
            return 0
        M = len(s1)
        N = len(s2)
        dp = [[0 for j in range(N)] for i in range(M)]
        # dp初始
        if s1[0]==s2[0]:
            dp[0][0] = 1
        for j in range(1, N):
            if s1[0]==s2[j]:
                dp[0][j] = 1 #
            else:
                dp[0][j] = dp[0][j-1]
        for i in range(1, M):
            if s1[i]==s2[0]:
                dp[i][0] = 1 #
            else:
                dp[i][0] = dp[i-1][0]
        # 更新dp
        for i in range(1, M):
            for j in range(1, N):
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                if s1[i]==s2[j]:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1)
        return dp[-1][-1]
```
附加，返回最长的公共子序列，而不仅仅是长度。
```python
    def longestCommonSequence(self, s1, s2):
        if not s1 or not s2:
            return ''
        M = len(s1)
        N = len(s2)
        dp = [[0 for j in range(N)] for i in range(M)]
        # dp初始
        if s1[0]==s2[0]:
            dp[0][0] = 1
        for j in range(1, N):
            if s1[0]==s2[j]:
                dp[0][j] = 1 #
            else:
                dp[0][j] = dp[0][j-1]
        for i in range(1, M):
            if s1[i]==s2[0]:
                dp[i][0] = 1 #
            else:
                dp[i][0] = dp[i-1][0]
        # 更新dp
        for i in range(1, M):
            for j in range(1, N):
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                if s1[i]==s2[j]:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1)
        # 从后往前找最长公共子序列
        maxlen = dp[-1][-1]
        i, j = M-1, N-1
        res = ''
        print(maxlen)
        while maxlen>0:
            # 相等，是从左上角来的，还原回去
            if s1[i]==s2[j]:
                res = s1[i] + res
                i -= 1
                j -= 1
                maxlen -= 1
            # 不等，可能是从上边来的
            elif i>0 and dp[i][j]==dp[i-1][j]:
                i -= 1
            # 不等，也可能是从左边来的
            elif j>0 and dp[i][j]==dp[i][j-1]:
                j -= 1
        return res
```
# 309. Best Time to Buy and Sell Stock with Cooldown
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:
```
Input: [1,2,3,0,2]
Output: 3 
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```
分析：设sell[i]为到i为止，从开头到最后一个以sell结尾，产生的最大利润。设buy[i]为到i为止，从开头到最后一个以buy结尾，产的最大利润。有
```python
buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);   
sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
```
这个问题的关键是<font color = red> 理解 buy[i]的含义</font>。

Runtime: 24 ms, faster than 81.58%
```python
    def maxProfit(self, prices):
        if len(prices)<2:
            return 0
        sell, buy, pre_sell, pre_buy = 0, -prices[0], 0, 0
        for price in prices:
            pre_buy = buy
            buy = max(pre_buy, pre_sell-price)
            pre_sell = sell
            sell = max(pre_sell, pre_buy+price)
        return sell
```





